<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Time response · MultipleScattering.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="MultipleScattering.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MultipleScattering.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../source/">RegularSources</a></li><li><a class="tocitem" href="../shapes/">Shapes</a></li><li><a class="tocitem" href="../particles/">Particles</a></li><li class="is-active"><a class="tocitem" href>Time response</a><ul class="internal"><li><a class="tocitem" href="#impulse_intro"><span>Intro</span></a></li><li><a class="tocitem" href="#Gaussian-impulse"><span>Gaussian impulse</span></a></li><li><a class="tocitem" href="#Discrete-impulse"><span>Discrete impulse</span></a></li><li><a class="tocitem" href="#Scattering-example"><span>Scattering example</span></a></li><li><a class="tocitem" href="#impulse_details"><span>Technical details</span></a></li></ul></li><li><a class="tocitem" href="../plot/">Plotting</a></li><li><a class="tocitem" href="../new_types/">New particles</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../library/base/">Base</a></li><li><a class="tocitem" href="../../library/acoustics/">Acoustic</a></li><li><a class="tocitem" href="../../library/random/">Random</a></li></ul></li><li><a class="tocitem" href="../../maths/README/">Theory</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../example/README/">Overview</a></li><li><a class="tocitem" href="../../example/box_size/README/">Box size</a></li><li><a class="tocitem" href="../../example/hankel_convergence/README/">Convergence when increasing the number of Hankel functions</a></li><li><a class="tocitem" href="../../example/moments/README/">StatisticalMoments</a></li><li><a class="tocitem" href="../../example/near_surface_backscattering/README/">Near-surface backscattering</a></li><li><a class="tocitem" href="../../example/random_particles/README/">Simple random particles example</a></li><li><a class="tocitem" href="../../example/time_response_single_particle/README/">Time response from single particle</a></li><li><a class="tocitem" href="../../example/two_particles/README/">OUT-DATED needs to be updated</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Time response</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Time response</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaWaveScattering/MultipleScattering.jl/blob/master/docs/src/manual/time_response.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Time-response"><a class="docs-heading-anchor" href="#Time-response">Time response</a><a id="Time-response-1"></a><a class="docs-heading-anchor-permalink" href="#Time-response" title="Permalink"></a></h1><p>This package calculates all scattering in the frequency domain, and we call the resulting field the frequency response <span>$\hat u(\mathbf x,\omega)$</span>, which satisfies <span>$\nabla^2 \hat u(\mathbf x,\omega) + k^2 \hat u(\mathbf x,\omega) = 0$</span>, where <span>$k = \omega/c$</span>. We can transform the frequency response <span>$\hat u(\mathbf x,\omega)$</span> into a time response <span>$u(\mathbf x,t)$</span> using a Fourier transform, where <span>$u(\mathbf x,t)$</span> satisfies <span>$\nabla^2 u(\mathbf x,t) - \frac{1}{c^2}  \frac{\partial^2}{\partial t^2}u(\mathbf x,t) = 0$</span>. For a minimal example see <a href="../intro/#Results-in-time">Results in time</a>, or see <a href="#impulse_details">Technical details</a> for more maths.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The package assumes the time response <span>$u(\mathbf x,t)$</span> is always real, this simplifies the Fourier transform.</p></div></div><h2 id="impulse_intro"><a class="docs-heading-anchor" href="#impulse_intro">Intro</a><a id="impulse_intro-1"></a><a class="docs-heading-anchor-permalink" href="#impulse_intro" title="Permalink"></a></h2><p>As an example, let use a plane-wave source <span>$\mathrm e^{\mathrm i \omega x}$</span> and measure the response at origin of the source <span>$x = (0,0)$</span>,</p><pre><code class="language-julia hljs">plane_wave = plane_source(Acoustic(1.0, 1.0, 2); direction = [1.0,0.0], position = [0.0,0.0]);
x = [[0.0,0.0]];
ωs = LinRange(0.0,1.0,100);
freq_response = run(plane_wave, x, ωs);
t_vec = LinRange(-20.0,80.,110);
time_response = frequency_to_time(freq_response; t_vec = t_vec);
typeof(time_response)

# output

TimeSimulationResult{Float64,2,1}</code></pre><p>where we specified the times <code>t_vec</code> to calculate <code>time_response</code>. If no <code>t_vec</code> is given, the default times would be <code>t_vec = ω_to_t(ωs)</code> which is the standard choice for the Discrete Fourier Transform.  </p><p>Let us have a look at these responses:</p><pre><code class="language-julia hljs">using Plots
p1 = plot(freq_response, xlims = (0,2), ylims = (0.,1.5), field_apply = real);
p2 = plot(time_response);
plot(p1,p2)</code></pre><p><img src="../../assets/sinc_impulse.png" alt="A discrete delta impulse"/></p><p>Note how the time response has lobes after and before the largest signal. This is often undesirable, as we usually want signal which are compact in the time domain, i.e. zero before and after the largest signal. These lobes are called Gibbs Phenomena. They are caused by only calculating the frequency response <span>$\hat u(\mathbf x,\omega)$</span> up to <span>$\omega \leq 1$</span>, and then (usually), taking <span>$\hat u(\mathbf x,\omega) = 0$</span> for <span>$\omega &gt; 1$</span> when calculating the Fourier transform.   </p><p>We can alter the response, in time and frequency, by specifying an impulse function <span>$\hat f(\omega)$</span> which will use <span>$\hat \phi(\mathbf x, \omega) = \hat f(\omega) u(\mathbf x \omega)$</span> as the frequency response. For example, we can choose <span>$\hat f(\omega)$</span> to smooth out the drastic drop in <span>$\hat u(\mathbf 0,\omega)$</span> when <span>$\omega$</span> passes over <span>$\omega = 1$</span>.</p><h2 id="Gaussian-impulse"><a class="docs-heading-anchor" href="#Gaussian-impulse">Gaussian impulse</a><a id="Gaussian-impulse-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-impulse" title="Permalink"></a></h2><p>The simplest way to avoid unwanted lobes (and Gibbs phenomena) is to use a Gaussian impulse function:</p><pre><code class="language-julia hljs">maxω = maximum(ωs)
gauss_impulse = GaussianImpulse(maxω)
typeof(gauss_impulse)

# output

ContinuousImpulse{Float64}</code></pre><p>The argument <code>maxω</code> passed to <a href="../../library/base/#MultipleScattering.GaussianImpulse-Tuple{T} where T&lt;:AbstractFloat"><code>GaussianImpulse</code></a> will return an Gaussian impulse which will (mostly) avoid the lobes given by calculating only <code>ω &lt;= maxω</code>. The Gaussian impulse in frequency and time is</p><pre><code class="language-julia hljs">ωs_all = -2.0:0.01:2.0
p1 = plot(ω -&gt; real(gauss_impulse.in_freq(ω)), ωs_all, title=&quot;Gaussian in frequency&quot;)
p2 = plot(gauss_impulse.in_time, t_vec, title=&quot;Gaussian in time&quot;)
plot(p1,p2)</code></pre><p><img src="../../assets/gauss_impulse.png" alt="A Gaussian impulse"/></p><p>The analytic expression for these functions are <span>$\hat f(\omega) = 2 \sqrt{3 \pi / \Omega^2} \mathrm e^{-3 (\omega/\Omega)^2}$</span> and <span>$f(t) = \mathrm e^{-(t \Omega)^2 / 12}$</span>, where we used <span>$\Omega =  \mathrm{max}\,\omega$</span>.</p><p>To use this impulse we simply:</p><pre><code class="language-julia hljs">gauss_time_response = frequency_to_time(freq_response; t_vec = t_vec, impulse = gauss_impulse);
p1 = plot(time_response);
p2 = plot(gauss_time_response);
plot(p1,p2)</code></pre><p><img src="../../assets/compare_gauss_impulse.png" alt="Compare the Gaussian impulse"/></p><p>There are still some lobes present because again <code>freq_response</code> only calculates <code>ω&lt;=1.0</code>,  but this time the drop is much less pronounced, which we can demonstrate with a plot of <span>$\hat \phi(\mathbf 0, \omega)$</span>:  </p><pre><code class="language-julia hljs">φs = field(freq_response)[:] .* gauss_impulse.in_freq.(ωs)
plot(ωs, real.(φs), title=&quot;Frequency response φ&quot;)</code></pre><p><img src="../../assets/freq_gauss.png" alt="Compare the Gaussian impulse"/></p><h2 id="Discrete-impulse"><a class="docs-heading-anchor" href="#Discrete-impulse">Discrete impulse</a><a id="Discrete-impulse-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-impulse" title="Permalink"></a></h2><p>The only impulse the package provides is the Gaussian, both its discrete <a href="../../library/base/#MultipleScattering.DiscreteGaussianImpulse-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}, Tuple{AbstractArray{T,N} where N,AbstractArray{T,N} where N}} where T"><code>DiscreteGaussianImpulse</code></a> and analytic form <a href="../../library/base/#MultipleScattering.GaussianImpulse-Tuple{T} where T&lt;:AbstractFloat"><code>GaussianImpulse</code></a>. But all this is not necessary to use your own defined impulse function. You only need to define an impulse sampled in frequency. For example suppose we want a triangle impulse in frequency:</p><pre><code class="language-julia hljs"># we need only define for ω &gt; 0.
triangle_freq(ω) = 5 - 5*ω

# we only need the sampled frequency response.
in_freq = triangle_freq.(ωs)

# as we have specified in_freq we do not need to specify in_time.
in_time = 0.0*t_vec

discrete_impulse = DiscreteImpulse(t_vec, in_time, ωs, in_freq)

time_response = frequency_to_time(freq_response; t_vec = t_vec, discrete_impulse = discrete_impulse);

typeof(time_response)</code></pre><pre><code class="language-julia hljs">plot(time_response)</code></pre><p><img src="../../assets/triangle_freq_response.png" alt/></p><p>Alternatively, we can attempt to produce a triangle wave in the time domain, for which there is a convenient constructor:</p><pre><code class="language-julia hljs">triangle_time(t) = (abs(t/15) &lt; 1) ? 1 - abs(t/15) : 0.0

in_time = triangle_time.(t_vec)

# the function DiscreteImpulse below will calculate in_freq
discrete_impulse = DiscreteImpulse(t_vec, in_time, ωs)

time_response = frequency_to_time(freq_response; t_vec = t_vec, discrete_impulse = discrete_impulse);</code></pre><p><img src="../../assets/triangle_time_response.png" alt/></p><h2 id="Scattering-example"><a class="docs-heading-anchor" href="#Scattering-example">Scattering example</a><a id="Scattering-example-1"></a><a class="docs-heading-anchor-permalink" href="#Scattering-example" title="Permalink"></a></h2><p>As an example, we will make a reflective lens out of particles. To achieve this we will place the particles into a region with the shape <a href="../../library/base/#MultipleScattering.TimeOfFlightPlaneWaveToPoint"><code>TimeOfFlightPlaneWaveToPoint</code></a>.</p><p>First we choose the properties of the lens:</p><pre><code class="language-julia hljs">p_radius = 0.1
volfrac = 0.3

x = [-10.0;0.0]
outertime = 34.8
innertime = 34.0

# Generate particles which are at most outertime away from our listener
outershape = TimeOfFlightPlaneWaveToPoint(x, outertime)
outerparticles = random_particles(Acoustic(2; ρ=0.0, c=0.0), Circle(p_radius);
        region_shape = outershape,
        volume_fraction = volfrac,
        seed=2
);

# Filter out particles which are less than innertime away
innershape = TimeOfFlightPlaneWaveToPoint(x, innertime + 4*p_radius); # the + 4*p_radius is to account for double the particle diameter
particles = filter(p -&gt; p⊈innershape, outerparticles);

plot(particles)</code></pre><p><img src="../../assets/lens-particles.png" alt/></p><p>Next we simulate an impulse plane-wave starting at <span>$x = -10$</span>:</p><pre><code class="language-julia hljs">ωs = LinRange(0.01,2.0,100)

plane_wave = plane_source(Acoustic(1.0, 1.0, 2); direction = [1.0,0.0], position = x);
sim = FrequencySimulation(particles, plane_wave);

freq_response = run(sim, x, ωs);

t_vec = -10.:0.2:81.
time_response = frequency_to_time(freq_response; t_vec=t_vec, impulse = GaussianImpulse(1.5; σ = 1.0))

xticks = [0.,20.,34.,40.0,60.,80.]
plot(time_response, title=&quot;Time response from lens&quot;, label=&quot;&quot;, xticks=xticks)</code></pre><p><img src="../../assets/lens-response.png" alt/></p><p>The first peak is the incident wave, and the next peak is the wave scattered from the lens which should arrive close to <code>t = 34</code>.</p><h2 id="impulse_details"><a class="docs-heading-anchor" href="#impulse_details">Technical details</a><a id="impulse_details-1"></a><a class="docs-heading-anchor-permalink" href="#impulse_details" title="Permalink"></a></h2><p>We can calculate the time response <span>$u(\mathbf x,t)$</span>, from the frequency response <span>$\hat u(\mathbf x, \omega)$</span> by approximating the Fourier transform:</p><p class="math-container">\[u(\mathbf x,t) = \frac{1}{2\pi} \int_{-\infty}^\infty \hat u(\mathbf x, \omega)\mathrm e^{-\mathrm i \omega t} d\omega,
\quad \hat u(\mathbf x, \omega) = \int_{-\infty}^\infty u(\mathbf x, t)\mathrm e^{\mathrm i \omega t} dt,\]</p><p>where the second equation is the inverse transform. To modify the time response <span>$u$</span>, we can specify an impulse function <span>$\hat f(\omega)$</span> which gives an new time response function <span>$\phi(\mathbf x, t)$</span>:</p><p class="math-container">\[\phi(\mathbf x, t) = \frac{1}{2\pi} \int_{-\infty}^\infty \hat f(\omega) \hat u(\mathbf x, \omega)\mathrm e^{-\mathrm i \omega t} d\omega = \frac{1}{\pi}\mathrm{Re}\, \int_0^\Omega \hat f(\omega) \hat u(\mathbf x, \omega)\mathrm e^{-\mathrm i \omega t} d\omega\]</p><p>where the second identity results from assuming that <span>$\phi(\mathbf x, t)$</span> is real, with <span>$\mathrm Re$</span> being the real part. Also note that <span>$\phi(\mathbf x,t) = (f * u)(\mathbf x, t)$</span>, where <span>$*$</span> is a convolution in time.</p><p>To approximate the above integral as finite integral, one option is to assume that <span>$|\hat f(\omega) \hat u(\mathbf x, \omega)| \to 0$</span> as <span>$|\omega| \to 0$</span>, which would allow us to truncate the integration domain between <span>$\omega \in [-\Omega, \Omega]$</span>. We also need to discretise the integral. Putting both of these together results in</p><p class="math-container">\[\phi(\mathbf x, t) \approx \frac{1}{\pi}\mathrm{Re}\, \sum_{m=0}^M \hat f(\omega_m) \hat u(\mathbf x, \omega_m)\mathrm e^{-\mathrm i \omega_m t} \Delta \omega_m,\]</p><p>where <span>$\omega_M = \Omega$</span> and <span>$\Delta \omega_m$</span> depends on the scheme used, with the simplest being <span>$\Delta \omega_m = \omega_{m+1} - \omega_{m}$</span>.</p><p>To learn more see the notes <a href="../../maths/DiscreteFourier.pdf">Discrete Fourier Transform</a> or the tests in the folder test of the source code.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The standard way to sample the frequencies is to take <span>$\omega_m = m \Delta \omega$</span> and <span>$\Delta \omega_m = \Delta \omega$</span> for some constant <span>$\Delta \omega$</span>. If we substitute this sampling into the approximation for <span>$\phi(\mathbf x, t)$</span>, shown above, we find that <span>$\phi(\mathbf x,t)$</span> becomes periodic in time <span>$t$</span> with period <span>$T = 2\pi / \Delta \omega$</span>. That is <span>$\phi(\mathbf x, t + T) = \phi(\mathbf x, t)$</span> for every <span>$t$</span>. Suppose you were calculating a scattered wave that arrives at time <span>$t = T + \tau$</span>, what would happen? The answer is you would see this scattered wave arrive at time <span>$t = \tau$</span>, assuming <span>$\tau &lt; T$</span>. This wrong arrival time occurs often when waves get trapped due to strong multiple scattering.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../particles/">« Particles</a><a class="docs-footer-nextpage" href="../plot/">Plotting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 2 November 2021 15:21">Tuesday 2 November 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

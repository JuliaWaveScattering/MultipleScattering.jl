<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Time response · MultipleScattering.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="MultipleScattering.jl logo"/></a><h1>MultipleScattering.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../intro/">Introduction</a></li><li><a class="toctext" href="../source/">Sources</a></li><li><a class="toctext" href="../shapes/">Shapes</a></li><li><a class="toctext" href="../particles/">Particles</a></li><li class="current"><a class="toctext" href>Time response</a><ul class="internal"><li><a class="toctext" href="#impulse_intro-1">Intro</a></li><li><a class="toctext" href="#Gaussian-impulse-1">Gaussian impulse</a></li><li><a class="toctext" href="#Discrete-impulse-1">Discrete impulse</a></li><li><a class="toctext" href="#impulse_details-1">Technical details</a></li></ul></li><li><a class="toctext" href="../plot/">Plotting</a></li><li><a class="toctext" href="../new_types/">New particles</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../../library/base/">Base</a></li><li><a class="toctext" href="../../library/acoustics/">Acoustic</a></li><li><a class="toctext" href="../../library/random/">Random</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../example/README/">Examples</a></li><li><a class="toctext" href="../../example/box_size/README/">Box size</a></li><li><a class="toctext" href="../../example/hankel_convergence/README/">Convergence when increasing the number of Hankel functions</a></li><li><a class="toctext" href="../../example/lens/README/">Lens</a></li><li><a class="toctext" href="../../example/moments/README/">StatisticalMoments</a></li><li><a class="toctext" href="../../example/near_surface_backscattering/README/">Near-surface backscattering</a></li><li><a class="toctext" href="../../example/random_particles/README/">Simple random particles example</a></li><li><a class="toctext" href="../../example/time_response_single_particle/README/">Time response from single particle</a></li><li><a class="toctext" href="../../example/two_particles/README/">Two particles</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Time response</a></li></ul><a class="edit-page" href="https://github.com/jondea/MultipleScattering.jl/blob/master/docs/src/manual/time_response.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Time response</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Time-response-1" href="#Time-response-1">Time response</a></h1><p>This package calculates all scattering in the frequency domain, and we call the resulting field the frequency response <span>$\hat u(\mathbf x,\omega)$</span>, which satisfies <span>$\nabla^2 \hat u(\mathbf x,\omega) + k^2 \hat u(\mathbf x,\omega) = 0$</span>, where <span>$k = \omega/c$</span>. We can transform the frequency response <span>$\hat u(\mathbf x,\omega)$</span> into a time response <span>$u(\mathbf x,t)$</span> using a Fourier transform, where <span>$u(\mathbf x,t)$</span> satisfies <span>$\nabla^2 u(\mathbf x,t) - \frac{1}{c^2}  \frac{\partial^2}{\partial t^2}u(\mathbf x,t) = 0$</span>. For a minimal example see <a href="../intro/#Results-in-time-1">Results in time</a>, or see <a href="#impulse_details-1">Technical details</a> for more maths.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The package assumes the time response <span>$u(\mathbf x,t)$</span> is always real, this simplifies the Fourier transform.</p></div></div><h2><a class="nav-anchor" id="impulse_intro-1" href="#impulse_intro-1">Intro</a></h2><p>As an example, let use a plane-wave source <span>$\mathrm e^{\mathrm i \omega x}$</span> and measure the response at origin of the source <span>$x = (0,0)$</span>,</p><pre><code class="language-julia">plane_wave = plane_source(Acoustic(1.0, 1.0, 2); direction = [1.0,0.0], position = [0.0,0.0]);
x = [[0.0,0.0]];
ωs = LinRange(0.0,1.0,100);
freq_response = run(plane_wave, x, ωs);
t_vec = LinRange(-20.0,80.,110);
time_response = frequency_to_time(freq_response; t_vec = t_vec);
typeof(time_response)

# output

TimeSimulationResult{Float64,2,1}</code></pre><p>where we specified the times <code>t_vec</code> to calculate <code>time_response</code>. If no <code>t_vec</code> is given, the default times would be <code>t_vec = ω_to_t(ωs)</code> which is the standard choice for the Discrete Fourier Transform.  </p><p>Let us have a look at these responses:</p><pre><code class="language-julia">using Plots
p1 = plot(freq_response, xlims = (0,2), ylims = (0.,1.5), field_apply = real);
p2 = plot(time_response);
plot(p1,p2)</code></pre><p><img src="../../assets/sinc_impulse.png" alt="A discrete delta impulse"/></p><p>Note how the time response has lobes after and before the largest signal. This is often undesirable, as we usually want signal which are compact in the time domain, i.e. zero before and after the largest signal. These lobes are called Gibbs Phenomena. They are caused by only calculating the frequency response <span>$\hat u(\mathbf x,\omega)$</span> up to <span>$\omega \leq 1$</span>, and then (usually), taking <span>$\hat u(\mathbf x,\omega) = 0$</span> for <span>$\omega &gt; 1$</span> when calculating the Fourier transform.   </p><p>We can alter the response, in time and frequency, by specifying an impulse function <span>$\hat f(\omega)$</span> which will use <span>$\hat \phi(\mathbf x, \omega) = \hat f(\omega) u(\mathbf x \omega)$</span> as the frequency response. For example, we can choose <span>$\hat f(\omega)$</span> to smooth out the drastic drop in <span>$\hat u(\mathbf 0,\omega)$</span> when <span>$\omega$</span> passes over <span>$\omega = 1$</span>.</p><h2><a class="nav-anchor" id="Gaussian-impulse-1" href="#Gaussian-impulse-1">Gaussian impulse</a></h2><p>The simplest way to avoid unwanted lobes (and Gibbs phenomena) is to use a Gaussian impulse function:</p><pre><code class="language-julia">maxω = maximum(ωs)
gauss_impulse = GaussianImpulse(maxω)
typeof(gauss_impulse)

# output

ContinuousImpulse{Float64}</code></pre><p>The argument <code>maxω</code> passed to <a href="../../library/base/#MultipleScattering.GaussianImpulse-Union{Tuple{T}, Tuple{T}, Tuple{T,T}} where T&lt;:AbstractFloat"><code>GaussianImpulse</code></a> will return an Gaussian impulse which will (mostly) avoid the lobes given by calculating only <code>ω &lt;= maxω</code>. The Gaussian impulse in frequency and time is</p><pre><code class="language-julia">ωs_all = -2.0:0.01:2.0
p1 = plot(ω -&gt; real(gauss_impulse.in_freq(ω)), ωs_all, title=&quot;Gaussian in frequency&quot;)
p2 = plot(gauss_impulse.in_time, t_vec, title=&quot;Gaussian in time&quot;)
plot(p1,p2)</code></pre><p><img src="../../assets/gauss_impulse.png" alt="A Gaussian impulse"/></p><p>The analytic expression for these functions are <span>$\hat f(\omega) = 2 \sqrt{3 \pi / \Omega^2} \mathrm e^{-3 (\omega/\Omega)^2}$</span> and <span>$f(t) = \mathrm e^{-(t \Omega)^2 / 12}$</span>, where we used <span>$\Omega =  \mathrm{max}\,\omega$</span>.</p><p>To use this impulse we simply:</p><pre><code class="language-julia">gauss_time_response = frequency_to_time(freq_response; t_vec = t_vec, impulse = gauss_impulse);
p1 = plot(time_response);
p2 = plot(gauss_time_response);
plot(p1,p2)</code></pre><p><img src="../../assets/compare_gauss_impulse.png" alt="Compare the Gaussian impulse"/></p><p>There are still some lobes present because again <code>freq_response</code> only calculates <code>ω&lt;=1.0</code>,  but this time the drop is much less pronounced, which we can demonstrate with a plot of <span>$\hat \phi(\mathbf 0, \omega)$</span>:  </p><pre><code class="language-julia">φs = field(freq_response)[:] .* gauss_impulse.in_freq.(ωs)
plot(ωs, real.(φs), title=&quot;Frequency response φ&quot;)</code></pre><p><img src="../../assets/freq_gauss.png" alt="Compare the Gaussian impulse"/></p><h2><a class="nav-anchor" id="Discrete-impulse-1" href="#Discrete-impulse-1">Discrete impulse</a></h2><p>The only impulse the package provides is the Gaussian, both its discrete <a href="../../library/base/#MultipleScattering.DiscreteGaussianImpulse-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}, Tuple{AbstractArray{T,N} where N,AbstractArray{T,N} where N}} where T"><code>DiscreteGaussianImpulse</code></a> and analytic form <a href="../../library/base/#MultipleScattering.GaussianImpulse-Union{Tuple{T}, Tuple{T}, Tuple{T,T}} where T&lt;:AbstractFloat"><code>GaussianImpulse</code></a>. But all this is not necessary to use your own defined impulse function. You only need to define an impulse sampled in frequency. For example suppose we want a triangle impulse in frequency:</p><pre><code class="language-julia"># we need only define for ω &gt; 0.
triangle_freq(ω) = 5 - 5*ω

# we only need the sampled frequency response.
in_freq = triangle_freq.(ωs)

# as we have specified in_freq we do not need to specify in_time.
in_time = 0.0*t_vec

discrete_impulse = DiscreteImpulse(t_vec, in_time, ωs, in_freq)

time_response = frequency_to_time(freq_response; t_vec = t_vec, discrete_impulse = discrete_impulse);

typeof(time_response)</code></pre><pre><code class="language-julia">plot(time_response)</code></pre><p><img src="../../assets/triangle_freq_response.png" alt/></p><p>Alternatively, we can attempt to produce a triangle wave in the time domain, for which there is a convenient constructor:</p><pre><code class="language-julia">triangle_time(t) = (abs(t/15) &lt; 1) ? 1 - abs(t/15) : 0.0

in_time = triangle_time.(t_vec)

# the function DiscreteImpulse below will calculate in_freq
discrete_impulse = DiscreteImpulse(t_vec, in_time, ωs)

time_response = frequency_to_time(freq_response; t_vec = t_vec, discrete_impulse = discrete_impulse);</code></pre><p><img src="../../assets/triangle_time_response.png" alt/></p><h2><a class="nav-anchor" id="impulse_details-1" href="#impulse_details-1">Technical details</a></h2><p>We can calculate the time response <span>$u(\mathbf x,t)$</span>, from the frequency response <span>$\hat u(\mathbf x, \omega)$</span> by approximating the Fourier transform:</p><div>\[u(\mathbf x,t) = \frac{1}{2\pi} \int_{-\infty}^\infty \hat u(\mathbf x, \omega)\mathrm e^{-\mathrm i \omega t} d\omega,
\quad \hat u(\mathbf x, \omega) = \int_{-\infty}^\infty u(\mathbf x, t)\mathrm e^{\mathrm i \omega t} dt,\]</div><p>where the second equation is the inverse transform. To modify the time response <span>$u$</span>, we can specify an impulse function <span>$\hat f(\omega)$</span> which gives an new time response function <span>$\phi(\mathbf x, t)$</span>:</p><div>\[\phi(\mathbf x, t) = \frac{1}{2\pi} \int_{-\infty}^\infty \hat f(\omega) \hat u(\mathbf x, \omega)\mathrm e^{-\mathrm i \omega t} d\omega = \frac{1}{\pi}\mathrm{Re}\, \int_0^\Omega \hat f(\omega) \hat u(\mathbf x, \omega)\mathrm e^{-\mathrm i \omega t} d\omega\]</div><p>where the second identity results from assuming that <span>$\phi(\mathbf x, t)$</span> is real, with <span>$\mathrm Re$</span> being the real part. Also note that <span>$\phi(\mathbf x,t) = (f * u)(\mathbf x, t)$</span>, where <span>$*$</span> is a convolution in time.</p><p>To approximate the above integral as finite integral, one option is to assume that <span>$|\hat f(\omega) \hat u(\mathbf x, \omega)| \to 0$</span> as <span>$|\omega| \to 0$</span>, which would allow us to truncate the integration domain between <span>$\omega \in [-\Omega, \Omega]$</span>. We also need to discretise the integral. Putting both of these together results in</p><div>\[\phi(\mathbf x, t) \approx \frac{1}{\pi}\mathrm{Re}\, \sum_{m=0}^M \hat f(\omega_m) \hat u(\mathbf x, \omega_m)\mathrm e^{-\mathrm i \omega_m t} \Delta \omega_m,\]</div><p>where <span>$\omega_M = \Omega$</span> and <span>$\Delta \omega_m$</span> depends on the scheme used, with the simplest being <span>$\Delta \omega_m = \omega_{m+1} - \omega_{m}$</span>.</p><p>To learn more see the notes <a href="../../maths/DiscreteFourier.pdf">Discrete Fourier Transform</a> or the tests in the folder test of the source code.</p><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>The most standard way to sample the frequencies is to take <span>$\omega_m = m \Delta \omega$</span> and <span>$\Delta \omega_m = \Delta \omega$</span>, for some fixed <span>$\Delta \omega$</span>. If we substitute this sampling into <span>$\phi(\mathbf x, t)$</span> we find that <span>$\phi$</span> becomes periodic in time with period <span>$T = \frac{2\pi n}{\Delta \omega}$</span>, that is <span>$\phi(\mathbf x, t + T) = \phi(\mathbf x, t)$</span> for every <span>$t$</span>. Suppose you wanted to calculate a scattered wave that arrives at time <span>$t = T + \tau$</span>, what would happen? The answer is you would see this scattered wave arrive at time <span>$t = \tau$</span> if <span>$\tau &lt; T$</span>. Note, this occurs often in this package because it is easy to get trapped waves when there is strong multiple scattering.</p></div></div><footer><hr/><a class="previous" href="../particles/"><span class="direction">Previous</span><span class="title">Particles</span></a><a class="next" href="../plot/"><span class="direction">Next</span><span class="title">Plotting</span></a></footer></article></body></html>

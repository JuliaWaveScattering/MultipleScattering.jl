var documenterSearchIndex = {"docs":
[{"location":"manual/time_response/#Time-response-1","page":"Time response","title":"Time response","text":"","category":"section"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"DocTestSetup = quote\n    using MultipleScattering\nend","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"This package calculates all scattering in the frequency domain, and we call the resulting field the frequency response hat u(mathbf xomega), which satisfies nabla^2 hat u(mathbf xomega) + k^2 hat u(mathbf xomega) = 0, where k = omegac. We can transform the frequency response hat u(mathbf xomega) into a time response u(mathbf xt) using a Fourier transform, where u(mathbf xt) satisfies nabla^2 u(mathbf xt) - frac1c^2  fracpartial^2partial t^2u(mathbf xt) = 0. For a minimal example see Results in time, or see Technical details for more maths.","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"note: Note\nThe package assumes the time response u(mathbf xt) is always real, this simplifies the Fourier transform.","category":"page"},{"location":"manual/time_response/#impulse_intro-1","page":"Time response","title":"Intro","text":"","category":"section"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"As an example, let use a plane-wave source mathrm e^mathrm i omega x and measure the response at origin of the source x = (00),","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"plane_wave = plane_source(Acoustic(1.0, 1.0, 2); direction = [1.0,0.0], position = [0.0,0.0]);\nx = [[0.0,0.0]];\nωs = LinRange(0.0,1.0,100);\nfreq_response = run(plane_wave, x, ωs);\nt_vec = LinRange(-20.0,80.,110);\ntime_response = frequency_to_time(freq_response; t_vec = t_vec);\ntypeof(time_response)\n\n# output\n\nTimeSimulationResult{Float64,2,1}","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"where we specified the times t_vec to calculate time_response. If no t_vec is given, the default times would be t_vec = ω_to_t(ωs) which is the standard choice for the Discrete Fourier Transform.  ","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"Let us have a look at these responses:","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"using Plots\np1 = plot(freq_response, xlims = (0,2), ylims = (0.,1.5), field_apply = real);\np2 = plot(time_response);\nplot(p1,p2)","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"(Image: A discrete delta impulse)","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"Note how the time response has lobes after and before the largest signal. This is often undesirable, as we usually want signal which are compact in the time domain, i.e. zero before and after the largest signal. These lobes are called Gibbs Phenomena. They are caused by only calculating the frequency response hat u(mathbf xomega) up to omega leq 1, and then (usually), taking hat u(mathbf xomega) = 0 for omega  1 when calculating the Fourier transform.   ","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"We can alter the response, in time and frequency, by specifying an impulse function hat f(omega) which will use hat phi(mathbf x omega) = hat f(omega) u(mathbf x omega) as the frequency response. For example, we can choose hat f(omega) to smooth out the drastic drop in hat u(mathbf 0omega) when omega passes over omega = 1.","category":"page"},{"location":"manual/time_response/#Gaussian-impulse-1","page":"Time response","title":"Gaussian impulse","text":"","category":"section"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"The simplest way to avoid unwanted lobes (and Gibbs phenomena) is to use a Gaussian impulse function:","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"maxω = maximum(ωs)\ngauss_impulse = GaussianImpulse(maxω)\ntypeof(gauss_impulse)\n\n# output\n\nContinuousImpulse{Float64}","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"The argument maxω passed to GaussianImpulse will return an Gaussian impulse which will (mostly) avoid the lobes given by calculating only ω <= maxω. The Gaussian impulse in frequency and time is","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"ωs_all = -2.0:0.01:2.0\np1 = plot(ω -> real(gauss_impulse.in_freq(ω)), ωs_all, title=\"Gaussian in frequency\")\np2 = plot(gauss_impulse.in_time, t_vec, title=\"Gaussian in time\")\nplot(p1,p2)","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"(Image: A Gaussian impulse)","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"The analytic expression for these functions are hat f(omega) = 2 sqrt3 pi  Omega^2 mathrm e^-3 (omegaOmega)^2 and f(t) = mathrm e^-(t Omega)^2  12, where we used Omega =  mathrmmaxomega.","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"To use this impulse we simply:","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"gauss_time_response = frequency_to_time(freq_response; t_vec = t_vec, impulse = gauss_impulse);\np1 = plot(time_response);\np2 = plot(gauss_time_response);\nplot(p1,p2)","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"(Image: Compare the Gaussian impulse)","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"There are still some lobes present because again freq_response only calculates ω<=1.0,  but this time the drop is much less pronounced, which we can demonstrate with a plot of hat phi(mathbf 0 omega):  ","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"φs = field(freq_response)[:] .* gauss_impulse.in_freq.(ωs)\nplot(ωs, real.(φs), title=\"Frequency response φ\")","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"(Image: Compare the Gaussian impulse)","category":"page"},{"location":"manual/time_response/#Discrete-impulse-1","page":"Time response","title":"Discrete impulse","text":"","category":"section"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"The only impulse the package provides is the Gaussian, both its discrete DiscreteGaussianImpulse and analytic form GaussianImpulse. But all this is not necessary to use your own defined impulse function. You only need to define an impulse sampled in frequency. For example suppose we want a triangle impulse in frequency:","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"# we need only define for ω > 0.\ntriangle_freq(ω) = 5 - 5*ω\n\n# we only need the sampled frequency response.\nin_freq = triangle_freq.(ωs)\n\n# as we have specified in_freq we do not need to specify in_time.\nin_time = 0.0*t_vec\n\ndiscrete_impulse = DiscreteImpulse(t_vec, in_time, ωs, in_freq)\n\ntime_response = frequency_to_time(freq_response; t_vec = t_vec, discrete_impulse = discrete_impulse);\n\ntypeof(time_response)","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"plot(time_response)","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"(Image: )","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"Alternatively, we can attempt to produce a triangle wave in the time domain, for which there is a convenient constructor:","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"triangle_time(t) = (abs(t/15) < 1) ? 1 - abs(t/15) : 0.0\n\nin_time = triangle_time.(t_vec)\n\n# the function DiscreteImpulse below will calculate in_freq\ndiscrete_impulse = DiscreteImpulse(t_vec, in_time, ωs)\n\ntime_response = frequency_to_time(freq_response; t_vec = t_vec, discrete_impulse = discrete_impulse);","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"(Image: )","category":"page"},{"location":"manual/time_response/#Scattering-example-1","page":"Time response","title":"Scattering example","text":"","category":"section"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"As an example, we will make a reflective lens out of particles. To achieve this we will place the particles into a region with the shape TimeOfFlight.","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"First we choose the properties of the lens:","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"p_radius = 0.1\nvolfrac = 0.3\n\nx = [-10.0;0.0]\noutertime = 34.8\ninnertime = 34.0\n\n# Generate particles which are at most outertime away from our listener\noutershape = TimeOfFlight(x, outertime)\nouterparticles = random_particles(Acoustic(2; ρ=0.0, c=0.0), Circle(p_radius);\n        region_shape = outershape,\n        volume_fraction = volfrac,\n        seed=2\n);\n\n# Filter out particles which are less than innertime away\ninnershape = TimeOfFlight(x, innertime + 4*p_radius); # the + 4*p_radius is to account for double the particle diameter\nparticles = filter(p -> p⊈innershape, outerparticles);\n\nplot(particles)","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"(Image: )","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"Next we simulate an impulse plane-wave starting at x = -10:","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"ωs = LinRange(0.01,2.0,100)\n\nplane_wave = plane_source(Acoustic(1.0, 1.0, 2); direction = [1.0,0.0], position = x);\nsim = FrequencySimulation(particles, plane_wave);\n\nfreq_response = run(sim, x, ωs);\n\nt_vec = -10.:0.2:81.\ntime_response = frequency_to_time(freq_response; t_vec=t_vec, impulse = GaussianImpulse(1.5, 1.0))\n\nxticks = [0.,20.,34.,40.0,60.,80.]\nplot(time_response, title=\"Time response from lens\", label=\"\", xticks=xticks)","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"(Image: )","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"The first peak is the incident wave, and the next peak is the wave scattered from the lens which should arrive close to t = 34.","category":"page"},{"location":"manual/time_response/#impulse_details-1","page":"Time response","title":"Technical details","text":"","category":"section"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"We can calculate the time response u(mathbf xt), from the frequency response hat u(mathbf x omega) by approximating the Fourier transform:","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"u(mathbf xt) = frac12pi int_-infty^infty hat u(mathbf x omega)mathrm e^-mathrm i omega t domega\nquad hat u(mathbf x omega) = int_-infty^infty u(mathbf x t)mathrm e^mathrm i omega t dt","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"where the second equation is the inverse transform. To modify the time response u, we can specify an impulse function hat f(omega) which gives an new time response function phi(mathbf x t):","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"phi(mathbf x t) = frac12pi int_-infty^infty hat f(omega) hat u(mathbf x omega)mathrm e^-mathrm i omega t domega = frac1pimathrmRe int_0^Omega hat f(omega) hat u(mathbf x omega)mathrm e^-mathrm i omega t domega","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"where the second identity results from assuming that phi(mathbf x t) is real, with mathrm Re being the real part. Also note that phi(mathbf xt) = (f * u)(mathbf x t), where * is a convolution in time.","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"To approximate the above integral as finite integral, one option is to assume that hat f(omega) hat u(mathbf x omega) to 0 as omega to 0, which would allow us to truncate the integration domain between omega in -Omega Omega. We also need to discretise the integral. Putting both of these together results in","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"phi(mathbf x t) approx frac1pimathrmRe sum_m=0^M hat f(omega_m) hat u(mathbf x omega_m)mathrm e^-mathrm i omega_m t Delta omega_m","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"where omega_M = Omega and Delta omega_m depends on the scheme used, with the simplest being Delta omega_m = omega_m+1 - omega_m.","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"To learn more see the notes Discrete Fourier Transform or the tests in the folder test of the source code.","category":"page"},{"location":"manual/time_response/#","page":"Time response","title":"Time response","text":"tip: Tip\nThe standard way to sample the frequencies is to take omega_m = m Delta omega and Delta omega_m = Delta omega for some constant Delta omega. If we substitute this sampling into the approximation for phi(mathbf x t), shown above, we find that phi(mathbf xt) becomes periodic in time t with period T = 2pi  Delta omega. That is phi(mathbf x t + T) = phi(mathbf x t) for every t. Suppose you were calculating a scattered wave that arrives at time t = T + tau, what would happen? The answer is you would see this scattered wave arrive at time t = tau, assuming tau  T. This wrong arrival time occurs often when waves get trapped due to strong multiple scattering.","category":"page"},{"location":"example/hankel_convergence/README/#Convergence-when-increasing-the-number-of-Hankel-functions-1","page":"Convergence when increasing the number of Hankel functions","title":"Convergence when increasing the number of Hankel functions","text":"","category":"section"},{"location":"example/hankel_convergence/README/#","page":"Convergence when increasing the number of Hankel functions","title":"Convergence when increasing the number of Hankel functions","text":"The code convergence.jl tests how fast does the scattered wave (in frequency) converge when increasing the number of Hankel functions. To describe the scattered wave from each particle we use a series of Hankel functions (of the first kind).","category":"page"},{"location":"example/hankel_convergence/README/#","page":"Convergence when increasing the number of Hankel functions","title":"Convergence when increasing the number of Hankel functions","text":"include(\"convergence.jl\")\nsimulations = hankel_order_convergence()\nplot_hankel_order_convergence(simulations)\n","category":"page"},{"location":"example/hankel_convergence/README/#","page":"Convergence when increasing the number of Hankel functions","title":"Convergence when increasing the number of Hankel functions","text":"(Image: Plot lens shape and response in time)","category":"page"},{"location":"example/hankel_convergence/README/#","page":"Convergence when increasing the number of Hankel functions","title":"Convergence when increasing the number of Hankel functions","text":"In the figures above m is the maximum order of the Hankel functions. The top left figure shows the configuration of particles considered.  ","category":"page"},{"location":"manual/shapes/#Shapes-1","page":"Shapes","title":"Shapes","text":"","category":"section"},{"location":"manual/shapes/#","page":"Shapes","title":"Shapes","text":"DocTestSetup = quote\n    using MultipleScattering\nend","category":"page"},{"location":"manual/shapes/#","page":"Shapes","title":"Shapes","text":"Shape is an abstract type which represents the shape of particles, and also the domain to place particles. See Shape for a list of relevant types and functions.","category":"page"},{"location":"manual/shapes/#Existing-shapes-1","page":"Shapes","title":"Existing shapes","text":"","category":"section"},{"location":"manual/shapes/#","page":"Shapes","title":"Shapes","text":"The package provides three basic shapes. You can plot them using:","category":"page"},{"location":"manual/shapes/#","page":"Shapes","title":"Shapes","text":"rectangle = Rectangle([0.0,-1.0],[1.0,2.0])\ncircle = Circle([-1.0,0.0],1.0)\ntimeofflight = TimeOfFlight([1.0,0.0],3.0)","category":"page"},{"location":"manual/shapes/#","page":"Shapes","title":"Shapes","text":"using Plots;\nplot(rectangle, linecolor = :red)\nplot!(circle, linecolor = :green)\nplot!(timeofflight, linecolor = :blue)","category":"page"},{"location":"manual/shapes/#","page":"Shapes","title":"Shapes","text":"(Image: Plot the three shapes)","category":"page"},{"location":"manual/shapes/#","page":"Shapes","title":"Shapes","text":"The Rectangle and TimeOfFlight are usually region where particles are placed. Time of flight is a shape which contains shapes from a half space which take at most t time to reach from the listener. The Circle is also used to define circular particles.","category":"page"},{"location":"example/box_size/README/#Box-size-1","page":"Box size","title":"Box size","text":"","category":"section"},{"location":"example/box_size/README/#","page":"Box size","title":"Box size","text":"If we are only interested in the response at a specific location for a certain time interval, we need only simulate particles which are this distance (or time) away from the listener.","category":"page"},{"location":"example/two_particles/README/#OUT-DATED-needs-to-be-updated-1","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"","category":"section"},{"location":"example/two_particles/README/#Two-particles-1","page":"OUT-DATED needs to be updated","title":"Two particles","text":"","category":"section"},{"location":"example/two_particles/README/#","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"Define two particles with the first centred at [1.,-2.], with radius 1.0, sound speed 2.0 and density 10.0","category":"page"},{"location":"example/two_particles/README/#","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"using MultipleScattering\nusing Plots\npyplot()\n\np1 = Particle([1.,-4.], 1.0; c = 20.0+0.0im, ρ = 10.)\np2 = Particle([3.,3.],  3.0; c = 1.0+0.0im, ρ = 0.1)\nparticles = [p1,p2]","category":"page"},{"location":"example/two_particles/README/#","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"Specify the angular frequency of the incident wave and calculate the response","category":"page"},{"location":"example/two_particles/README/#","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"w_arr = collect(0.1:0.01:1.)\nsimulation = FrequencySimulation(particles, w_arr)\nplot(simulation)","category":"page"},{"location":"example/two_particles/README/#","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"(Image: Plot against frequency)","category":"page"},{"location":"example/two_particles/README/#","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"The above used an incident plane with the default reciever/listener position and incident plane wave direction","category":"page"},{"location":"example/two_particles/README/#","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"simulation.listener_positions\nsimulation.source_direction","category":"page"},{"location":"example/two_particles/README/#","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"to change these defaults use","category":"page"},{"location":"example/two_particles/README/#","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"simulation = FrequencySimulation(particles, w_arr;\n    listener_positions = [-10.,-10.],\n    source_direction=[1.,1.])","category":"page"},{"location":"example/two_particles/README/#","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"then plot the response around the particles and receiver","category":"page"},{"location":"example/two_particles/README/#","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"w = 3.2\nplot(simulation,w; res=80, resp_fnc=abs)","category":"page"},{"location":"example/two_particles/README/#","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"(Image: Plot absolute value of wave field)","category":"page"},{"location":"example/two_particles/README/#","page":"OUT-DATED needs to be updated","title":"OUT-DATED needs to be updated","text":"the green circle in the plot is the receiver position. Looking at the region between the particles we see the complicated results of multiple scatttering.","category":"page"},{"location":"example/intro/README/#[Go-to-introductory-example](https://github.com/jondea/MultipleScattering.jl).-1","page":"Go to introductory example.","title":"Go to introductory example.","text":"","category":"section"},{"location":"maths/README/#Theory-1","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"maths/README/#","page":"Theory","title":"Theory","text":"Below are papers and notes that explain the theory behind this package.","category":"page"},{"location":"maths/README/#[The-T-matrix-and-Multiple-Scattering](T-matrix.pdf)-1","page":"Theory","title":"The T-matrix and Multiple Scattering","text":"","category":"section"},{"location":"maths/README/#","page":"Theory","title":"Theory","text":"These short notes introduce the T-matrix, which defines how a particle scatters waves, and shows how it used in multiple scattering from many particles.","category":"page"},{"location":"maths/README/#[Discrete-Fourier-Transform](DiscreteFourier.pdf)-1","page":"Theory","title":"Discrete Fourier Transform","text":"","category":"section"},{"location":"maths/README/#","page":"Theory","title":"Theory","text":"These notes give details on Green’s functions and Fourier transforms. We mostly focus on using discrete impulse functions.","category":"page"},{"location":"maths/README/#[T-matrix-Software](a9-ganesh.pdf)-1","page":"Theory","title":"T-matrix Software","text":"","category":"section"},{"location":"maths/README/#","page":"Theory","title":"Theory","text":"This paper describes a method to calculate the T-matrix for new particles.","category":"page"},{"location":"example/near_surface_backscattering/README/#Near-surface-backscattering-1","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"","category":"section"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"Near-surface backscattering is a method of accurately calculating the backscattering from an infinite halfspace. For just the code see backscattering.jl First, let us see why it is difficult to approximate the scattering from a halfspace filled with particles. That is, let us find out how many particles are required before the backscattering converges.","category":"page"},{"location":"example/near_surface_backscattering/README/#Generate-a-large-material-filled-with-particles.-1","page":"Near-surface backscattering","title":"Generate a large material filled with particles.","text":"","category":"section"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"using MultipleScattering\n\nhost_medium = Acoustic(1.0, 1.0, 2)\n\nradius = 0.8\nvolfrac = 0.10\nmax_width = 70.\n\nparticle_medium = Acoustic(0.2, 0.1, 2)\nparticle_shape = Circle(radius)\n\nbottomleft = [0.,-max_width]\ntopright = [max_width,max_width]\n\nshape = Rectangle(bottomleft,topright)\nparticles = random_particles(particle_medium, particle_shape; region_shape = shape, volume_fraction = volfrac)","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"We send an incoming harmonic plane wave and receive the backscattering at x:","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"using Plots\npyplot(linewidth=2)\n\nx = [-10.,0.]\nsource =  plane_source(host_medium; position = x,\n        direction = [1.0,0.],\n        amplitude = 1.0)\n\nplot(particles)\nscatter!([x[1]],[x[2]], lab=\"\")\nannotate!([(x[1], x[2] -max_width/10., \"Receiver\")])\nplot!(shape, linecolor = :red)","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"(Image: The largest quantity of particles used)","category":"page"},{"location":"example/near_surface_backscattering/README/#Calculate-backscattering-for-different-quantity-of-particles-1","page":"Near-surface backscattering","title":"Calculate backscattering for different quantity of particles","text":"","category":"section"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"We will shave off particles on the right of this group of particles (above), and then calculate the backscattered waves for a range of angular frequencies ωs.","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"ωs = collect(0.01:0.01:1.)\nwidths = 10.:5.:max_width\nnum_particles = zeros(length(widths))\n\nresults = map(eachindex(widths)) do i\n    bottomleft = [0.,-widths[i]]\n    topright = [widths[i],widths[i]]\n    shape = Rectangle(bottomleft, topright)\n\n    ps = filter(p -> p ⊆ shape, particles) # select particles that are inside shape\n    num_particles[i] = Int(length(ps))\n\n    simulation = FrequencySimulation(ps, source)\n    run(simulation, x, ωs)\nend\n\nbackscattered_waves = field.(results)\n\nM = length(backscattered_waves)\nbM = backscattered_waves[M] # backscattering from largest material\ndifferences = [norm(b - bM) for b in backscattered_waves[1:(M-1)]]./norm(bM)\n\nplot_converge = plot(num_particles[1:(M-1)], differences,\n    xlabel = \"number of particles\", ylabel =\"error %\",\n    label=\"frequency convergence\"\n)","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"(Image: The convergence of the response in frequency, when increasing the number of particles)","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"The graph shows the rate of convergence, that is, how much the backscattering changes when including more particles (making the material deeper). The graph has not clearly converged, so we can only conclude that more than 400 particles are needed to accurately approximate the backscattering from an infinite halfspace.","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"We can accelerate this convergence by considering backscattering in time.","category":"page"},{"location":"example/near_surface_backscattering/README/#Calculate-backscattering-in-time-1","page":"Near-surface backscattering","title":"Calculate backscattering in time","text":"","category":"section"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"time_simulations = frequency_to_time.(results)\nreceiver = results[1].x[1]\ntimes = 2*(widths .- receiver[1]) # time it takes for an incident plane wave to reach the furthest particles and then return to the receiver\n\nplot()\nfor i in [1,3,6,9,12,13]\n    plot!(time_simulations[i],label=\"$(num_particles[i]) particles\"\n        , xlims=(0,maximum(times)+10.), ylims=(-0.2,0.1)\n        , xticks = [0.; 30.; times]\n    )\nend\ngui()","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"(Image: The responses in time for different quantity of particles)","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"We see that the responses in time diverge from each other more and more as time goes by. Meaning that if we only calculate the response for a short amount of time 34, then the convergence will be accelerated.","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"time_vec = 0.:pi:34.2\ntime_results = frequency_to_time.(results; t_vec = time_vec, impulse = GaussianImpulse(maximum(ωs)))\n\nbackscattered_waves = field.(time_results)\nbM = backscattered_waves[M] # backscattering from largest material\ndifferences = [norm(b - bM) for b in backscattered_waves[1:(M-1)]]./norm(bM)\nplot(plot_converge)\nplot!(num_particles[1:(M-1)], differences, xlabel = \"number of particles\", ylabel =\"error %\", label=\"time convergence\")","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"(Image: Compare converges for responses in time and responses in frequency)","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"The convergence of the time response, for time 0<t<34, is much faster. In fact, less than 100 particles are needed to accurately approximate the backscattering from an infinite halfspace. The reason we don't show these as log plots is because there is a small constant error (about 0.01%) due to the discrete Fourier transform. This error is caused by the Gibbs phenomena and by assuming the backscattering is periodic (when it is not). Both these errors are well understood and can be controlled.","category":"page"},{"location":"example/near_surface_backscattering/README/#Calculate-backscattering-only-from-near-surface-particles-1","page":"Near-surface backscattering","title":"Calculate backscattering only from near-surface particles","text":"","category":"section"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"This last step is about efficiency. We want to only include particle which contribute to the backscattering for short time intervals. To do this we created a region called TimeOfFlight(listener,time), where every particle in this shape takes less than time for their first scattered wave (due to an incident plane wave) to return to the listener.  More precisely, if listener = (lx,ly), then every point (x,y) inside this shape satisfies: x-lx+((x-lx)^2+(y-ly)^2)^(1/2)<time and x>0.","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"For example, look at the largest quantity of particle we used","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"listener_position = [-10.,0.]\nshape = TimeOfFlight(listener_position,80.0)\nscatter([listener_position[1]],[listener_position[2]]);\nannotate!([(listener_position[1], listener_position[2] -max_width/10., \"Receiver\")])\nplot!.(particles);\nplot!(shape)","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"(Image: Shows the particles in the shape TimeOfFlight)","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"For time 0<t<80 the backscattering from these particles is the same as an infinite halfspace filled with particles. To achieve this result we need only the particles inside the shape TimeOfFlight (region with the red outline). The particles outside this shape were unnecessary. To see this inaction:","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"times = 40.:15.:80.\nnear_surface_simulations = map(times) do t\n    shape = TimeOfFlight(receiver,t) # choose a material with particles only in the near surface region\n    ps = filter(p -> p ⊆ shape, particles) # select particles that are inside shape\n    run(FrequencySimulation(ps, source), x, ωs) # calculate backscattering\nend\n\ntime_near_simulations = frequency_to_time.(near_surface_simulations; impulse = GaussianImpulse(maximum(ωs)))\n\nplot()\nfor i in 1:length(times)\n    plot!(time_near_simulations[i],label=\"time of flight $(times[i])\"\n        , xlims=(0,maximum(times)+10.), ylims=(-0.6,0.3)\n        , xticks = [0.; times], title=\"\"\n    )\nend\ngui()","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"(Image: Response from particles in the shapes TimeOfFlight)","category":"page"},{"location":"example/near_surface_backscattering/README/#","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"Note the incident pulse has a thickness of about 10 in time, which is why the time of flight 40 diverges from the other curves slightly before time 40, and likewise for the other curves.","category":"page"},{"location":"example/particles_in_circle/README/#Random-particles-in-a-circle-1","page":"Random particles in a circle","title":"Random particles in a circle","text":"","category":"section"},{"location":"example/particles_in_circle/README/#","page":"Random particles in a circle","title":"Random particles in a circle","text":"The code particlesincircle.jl compares the scattered wave from one big circle, with the scattered wave from a circle filled with small particles.","category":"page"},{"location":"example/particles_in_circle/README/#","page":"Random particles in a circle","title":"Random particles in a circle","text":"using MultipleScattering\n\n#You can also pick your own shape, an generate random particles inside it\n#with a certain radius ands volume fraction\nradius = 0.3\nvolfrac = 0.45\ncentre = [0.,0.]\nbig_radius = 3.0\n\nparticle_medium = Acoustic(2; ρ=0.0, c=0.0) # 2D particle with density ρ = 0.0 and soundspeed c = 0.0\nparticle_shape = Circle(radius)\n\ncircle = Circle(centre, big_radius)\n\nparticles = random_particles(particle_medium, particle_shape; region_shape = circle, volume_fraction = volfrac, seed=1)\n\nx = [-10.,0.] # position to receive the reflected wave\nhost_medium = Acoustic(2; ρ=1.0, c=1.0)\nsource =  plane_source(host_medium; position = x, direction = [1.0,0.])\nsimulation = FrequencySimulation(particles, source)","category":"page"},{"location":"example/particles_in_circle/README/#","page":"Random particles in a circle","title":"Random particles in a circle","text":"The particles chosen are impenetrable, i.e. the wave is 100\\% reflected. So this circle filled with scatterers should act like one big particle.","category":"page"},{"location":"example/particles_in_circle/README/#","page":"Random particles in a circle","title":"Random particles in a circle","text":"big_particle = Particle(particle_medium, circle)\nbig_particle_simulation = FrequencySimulation([big_particle], source)\n\n#define a bounding box for plot\n    bottomleft = [-10, -2*big_radius]\n    topright = [big_radius, 2*big_radius]\n    box = Rectangle(bottomleft, topright)\n\nusing Plots\nheight = 300\n#gr(size=(1.4*height,height))\npyplot(leg=false, size=(1.4*height,height))\n\nω = 0.5\nplot(big_particle_simulation, ω; res=15, bounds = box);\nplot!(big_particle)\n\n#savefig(\"plot_field_big.png\")\n\nplot(simulation, ω; res=15, bounds = box);\nplot!(particles, linecolor = :green)\n\n#savefig(\"plot_field.png\")","category":"page"},{"location":"example/particles_in_circle/README/#","page":"Random particles in a circle","title":"Random particles in a circle","text":"Resulting in the figures:","category":"page"},{"location":"example/particles_in_circle/README/#","page":"Random particles in a circle","title":"Random particles in a circle","text":"(Image: The field with big particle) (Image: The field with particles)","category":"page"},{"location":"example/particles_in_circle/README/#","page":"Random particles in a circle","title":"Random particles in a circle","text":"If we compare the response measured at the listener [-10., 0.], they should be very similar:","category":"page"},{"location":"example/particles_in_circle/README/#","page":"Random particles in a circle","title":"Random particles in a circle","text":"#define angular frequency range\nωs = collect(LinRange(0.1,1.0,10))\nresult = run(simulation, x, ωs)\nbig_result = run(big_particle_simulation, x, ωs)\n\nplot(result, lab = \"scattering from particles\")\nplot!(big_result,\n    lab = \"scattering from big particle\",\n    title=\"Compare scattered wave from one big particle, \\n and a circle filled with small particles\")","category":"page"},{"location":"example/particles_in_circle/README/#","page":"Random particles in a circle","title":"Random particles in a circle","text":"(Image: The response comparison)","category":"page"},{"location":"manual/particles/#Particles-1","page":"Particles","title":"Particles","text":"","category":"section"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"DocTestSetup = quote\n    using MultipleScattering\nend","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"Particle is a struct which define a scatterer, obstacle, or simply particle, which can scatter waves. See Particle for a list of relevant types and functions.","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"A Particle have two fields: medium and shape. The medium defines what kind of waves can propagate inside Particle, and what type of Source can be used to scatter waves from Particle. One example medium is Acoustic. The shape completely defines the geometry and position of the particle, see Shapes for details.","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"For an example we can define a circular particle with acoustics medium:","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"particle_medium =  Acoustic(2; ρ=10.0, c=2.0); # 2D acoustic particle with density ρ = 10.0 and soundspeed c = 2.0","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"mymedium = Acoustic(2; ρ=10.0, c=2.0); # 2D acoustics with density ρ = 10.0 and soundspeed c = 2.0\nmyshape = Circle([-2.0,2.0], 2.0);\np1 = Particle(mymedium, myshape);\nMultipleScattering.shape(p1) # we use \"MultipleScattering.\" just in case the function shape is already defined","category":"page"},{"location":"manual/particles/#Placing-particles-in-a-region-1","page":"Particles","title":"Placing particles in a region","text":"","category":"section"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"Suppose we want to place many circular particles in a region. The region has to be a pre-defined Shape, for example a Circle:","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"# Define the region\ncentre = [0.,0.]\nbig_radius = 3.0\ncircle = Circle(centre, big_radius)\n\n# Define the particle geometry and medium\np_radius = 0.3\nmyshape = Circle(p_radius) # we do not specify centre as it is not used by random_particles\nmymedium = Acoustic(2; ρ=10.0, c=2.0);\n\n# Generate particles inside circle\nvolfrac = 0.2\nparticles = random_particles(mymedium, myshape; region_shape = circle, volume_fraction = volfrac, seed=1);\n\nusing Plots\nplot(particles)\nplot!(circle, linecolor = :red)","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"(Image: Particles in circle)","category":"page"},{"location":"manual/particles/#Placing-polydisperse-particles-in-a-region-1","page":"Particles","title":"Placing polydisperse particles in a region","text":"","category":"section"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"Similar to the above, we can place particles with a range of shapes.","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"Suppose we want to add to the above example a range of smaller particles:","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"\n# Define a range of particles sizes\nrs = [0.05,0.15,0.15,0.2]; # by repeating the radius 0.15 twice, there will be twice as many particles with this radius.\nmyshapes = Circle.(rs)\nmymedium = Acoustic(2; ρ=0.2, c=0.2);\n\n# Generate particles inside circle\nvolfrac = 0.15\npolydisperse_particles = random_particles(mymedium, myshapes;\n    current_particles = particles,\n    region_shape = circle,\n    volume_fraction = volfrac,\n    seed=1\n);\n\nplot(polydisperse_particles, linecolor = :green)\nplot!(particles, linewidth = 2.0)\nplot!(circle, linecolor = :red)","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"(Image: Particles in circle)","category":"page"},{"location":"manual/particles/#Removing-particles-1","page":"Particles","title":"Removing particles","text":"","category":"section"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"Say we want to place a point-source within region filled with particles. To avoid placing the source inside any particle, we can remove a small region of particles:","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"small_circle = Circle(1.2)\n\nfilter!(p -> !(p ⊆ small_circle), polydisperse_particles)\n\nplot(polydisperse_particles, linecolor = :green)\nplot!(circle, linecolor = :red)","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"(Image: Particles in circle)","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"next we place a point source in the centre and plot the result, while excluding a small region Circle(0.1) to avoid the singularity caused by a point source:","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"ω = 0.4\npoint_wave = point_source(Acoustic(2; ρ=1.0, c=1.0), [0.0,0.0]);\nsim = FrequencySimulation(polydisperse_particles, point_wave);\nplot(sim, ω; res=20,\n       exclude_region = Circle(0.1),\n       drawparticles=true\n)","category":"page"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"(Image: Particles in circle)","category":"page"},{"location":"manual/particles/#Particle-internals-1","page":"Particles","title":"Particle internals","text":"","category":"section"},{"location":"manual/particles/#","page":"Particles","title":"Particles","text":"To define the scattering from a particle we use the T-matrix method. This package only exports T-matrix for circular Particle  and circular CapsuleParticle. To understand how to define new T-matrix read Notes on the T-matrix and see the source code of t_matrix.","category":"page"},{"location":"example/random_particles/README/#Simple-random-particles-example-1","page":"Simple random particles example","title":"Simple random particles example","text":"","category":"section"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"\n## Define particle properties\nDefine the volume fraction of particles, the region to place the particles, and their radius","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"julia using MultipleScattering num_particles = 4 radius = 1.0","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"particlemedium = Acoustic(2; ρ=0.2, c=0.1) # 2D particle with density ρ = 0.2 and soundspeed c = 0.1 particleshape = Circle(radius)","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"maxwidth = 20*radius bottomleft = [0.,-maxwidth] topright = [maxwidth,maxwidth] region_shape = Rectangle(bottomleft,topright)","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"particles = randomparticles(particlemedium, particleshape; regionshape = regionshape, numparticles = num_particles)","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"\nNow choose the receiver position `x`, the host medium, set plane wave as a source wave, and choose the angular frequency range `ωs`","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"julia x = [-10.,0.] hostmedium = Acoustic(2; ρ=1.0, c=1.0) source =  planesource(host_medium; position = x, direction = [1.0,0.])","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"ωs = LinRange(0.01,1.0,100)","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"simulation = FrequencySimulation(particles, source) result = run(simulation, x, ωs)","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"\nWe use the `Plots` package to plot both the response at the listener position x\n","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"julia     using Plots; #pyplot(linewidth = 2.0)     plot(result, fieldapply=real) # plot result     plot!(result, fieldapply=imag)     #savefig(\"plot_result.png\")","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"![Plot of response against wavenumber](plot_result.png)\n\nAnd plot the whole field inside the region_shape `bounds` for a specific wavenumber (`ω=0.8`)","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"julia     bottomleft = [-15.,-maxwidth]     topright = [maxwidth,max_width]     bounds = Rectangle(bottomleft,topright)","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"plot(simulation,0.8; res=80, bounds=bounds)\nplot!(region_shape, linecolor=:red)\nplot!(simulation)\nscatter!([x[1]],[x[2]], lab=\"receiver\")\n\n#savefig(\"plot_field.png\")","category":"page"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"``` (Image: Plot real part of acoustic field)","category":"page"},{"location":"example/random_particles/README/#Things-to-try-1","page":"Simple random particles example","title":"Things to try","text":"","category":"section"},{"location":"example/random_particles/README/#","page":"Simple random particles example","title":"Simple random particles example","text":"Try changing the volume fraction, particle radius and ω values we evaluate","category":"page"},{"location":"library/base/#Base-1","page":"Base","title":"Base","text":"","category":"section"},{"location":"library/base/#","page":"Base","title":"Base","text":"CurrentModule = MultipleScattering","category":"page"},{"location":"library/base/#","page":"Base","title":"Base","text":"Pages = [\"base.md\"]","category":"page"},{"location":"library/base/#base_shape-1","page":"Base","title":"Shape","text":"","category":"section"},{"location":"library/base/#","page":"Base","title":"Base","text":"Shape types and functions.","category":"page"},{"location":"library/base/#","page":"Base","title":"Base","text":"Shape\norigin\niscongruent(::Shape,::Shape)\ncongruent\nbounding_rectangle\nboundary_functions\nname\nouter_radius\nvolume\nCircle\nRectangle\nTimeOfFlightFromPoint\nTimeOfFlight\nSphere","category":"page"},{"location":"library/base/#MultipleScattering.Shape","page":"Base","title":"MultipleScattering.Shape","text":"Abstract idea which defines the external boundary of object.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.origin","page":"Base","title":"MultipleScattering.origin","text":"origin(shape::Shape)::SVector\n\nOrigin of shape, typically the center\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.iscongruent-Tuple{Shape,Shape}","page":"Base","title":"MultipleScattering.iscongruent","text":"iscongruent(p1::Shape, p2::Shape)::Bool\n≅(p1::Shape, p2::Shape)::Bool\n\nTrue if shapes are the same but in different positions (origins), standard mathematical definition.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.congruent","page":"Base","title":"MultipleScattering.congruent","text":"congruent(s::Shape, x)::Shape\n\nCreate shape congruent to s but with origin at x\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.bounding_rectangle","page":"Base","title":"MultipleScattering.bounding_rectangle","text":"Returns rectangle which completely encloses the shapes\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.boundary_functions","page":"Base","title":"MultipleScattering.boundary_functions","text":"volume(shape::Shape)::NTuple{Function,Dim)\n\nReturns Tuple of Dim Functions which define outer boundary of shape when given boundary coordinate t∈[0,1]\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.name","page":"Base","title":"MultipleScattering.name","text":"name(shape::Shape)::String\n\nName of a shape\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.outer_radius","page":"Base","title":"MultipleScattering.outer_radius","text":"outer_radius(shape::Shape{T})::T\n\nThe radius of a circle which completely contains the shape\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.volume","page":"Base","title":"MultipleScattering.volume","text":"volume(shape::Shape{T})::T\n\nVolume of a shape\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.Circle","page":"Base","title":"MultipleScattering.Circle","text":"Circle([origin=zeros(),] radius)\n\n2D Shape where boundary is a fixed distance from the origin.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.Rectangle","page":"Base","title":"MultipleScattering.Rectangle","text":"Rectangle([origin::AbstractVector{T}=zeros(),] width::T, Height::T)\nRectangle(bottomleft::AbstractVector{T}, topright::AbstractVector{T})\n\n2D Shape with axis aligned sides, defined by width, height and origin (at the center).\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.TimeOfFlightFromPoint","page":"Base","title":"MultipleScattering.TimeOfFlightFromPoint","text":"A shape where anything inside could cause a disturbance at the listener position from a point source wavefront starting at the listener. Also everything inside has a positive x coordinate. It is equivalent to a segment of a circle.\n\nMore precisely, if the listener is at (lx,ly) then the interior of the shape is defined as sqrt((x-lx)^2+(y-ly)^2)<time and x>0\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.TimeOfFlight","page":"Base","title":"MultipleScattering.TimeOfFlight","text":"A shape where anything inside could cause a disturbance at the listener position from a planar wavefront parallel to the y axis starting at the listener. Also everything inside has a positive x coordinate.\n\nMore precisely, if the listener is at (lx,ly) then the interior of the shape is defined as x-lx+sqrt((x-lx)^2+(y-l_y)^2)<time and x>0\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.Sphere","page":"Base","title":"MultipleScattering.Sphere","text":"Sphere([origin=zeros(),] radius)\n\n3D Shape where boundary is a fixed distance from the origin.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#base_physical_property-1","page":"Base","title":"Physical property","text":"","category":"section"},{"location":"library/base/#","page":"Base","title":"Base","text":"Physical properties types and functions.","category":"page"},{"location":"library/base/#","page":"Base","title":"Base","text":"PhysicalMedium\nfield_dim\ndim\noutgoing_basis_function\nregular_basis_function\ninternal_field\nboundary_data","category":"page"},{"location":"library/base/#MultipleScattering.PhysicalMedium","page":"Base","title":"MultipleScattering.PhysicalMedium","text":"Holds information about the physical properties of the medium, the dimension of the field and the number of dimensions it is a function of.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.outgoing_basis_function","page":"Base","title":"MultipleScattering.outgoing_basis_function","text":"Basis of outgoing wave functions in a specific dimension for specific physcial properties..\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.regular_basis_function","page":"Base","title":"MultipleScattering.regular_basis_function","text":"Basis functions in a specific dimension for specific physcial properties..\n\n\n\n\n\nBasis function when inside a particle. Assumes particle is a circle, which approximately works for all shapes.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.internal_field","page":"Base","title":"MultipleScattering.internal_field","text":"the field inside an AbstractParticle a some given point x.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.boundary_data","page":"Base","title":"MultipleScattering.boundary_data","text":"A tuples of vectors of the field close to the boundary of the shape. The field is calculated from sim::FrequencySimulation, but the PhysicalMedium inside and outside of the shape are assumed to be given by insidemedium and outsidemedium.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#base_particle-1","page":"Base","title":"Particle","text":"","category":"section"},{"location":"library/base/#","page":"Base","title":"Base","text":"Particle types and functions.","category":"page"},{"location":"library/base/#","page":"Base","title":"Base","text":"AbstractParticle\nParticle\nCapsuleParticle\niscongruent(::AbstractParticle,::AbstractParticle)","category":"page"},{"location":"library/base/#MultipleScattering.AbstractParticle","page":"Base","title":"MultipleScattering.AbstractParticle","text":"Object we can scatter waves off\n\nSubtypes will contain information about shape and material properties. Most crucially, they will implement the t_matrix function\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.Particle","page":"Base","title":"MultipleScattering.Particle","text":"Particle(medium::PhysicalMedium, shape::Shape)\n\nCreate particle with inner medium and shape (types and dimension must agree).\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.CapsuleParticle","page":"Base","title":"MultipleScattering.CapsuleParticle","text":"CapsuleParticle(outer::Particle, inner::Particle)\n\nA particle within another particle, both with the same shape type and origin.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.iscongruent-Tuple{AbstractParticle,AbstractParticle}","page":"Base","title":"MultipleScattering.iscongruent","text":"iscongruent(p1::AbstractParticle, p2::AbstractParticle)::Bool\n≅(p1::AbstractParticle, p2::AbstractParticle)::Bool\n\nReturns true if medium and shape of particles are the same, ignoring origin, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#source_base-1","page":"Base","title":"Source","text":"","category":"section"},{"location":"library/base/#","page":"Base","title":"Base","text":"Source types and functions.","category":"page"},{"location":"library/base/#","page":"Base","title":"Base","text":"Modules = [MultipleScattering]\nOrder   = [:type, :function]\nPages   = [\"src/source.jl\"]","category":"page"},{"location":"library/base/#MultipleScattering.AbstractSource","page":"Base","title":"MultipleScattering.AbstractSource","text":"Represent any source (incident) wave\n\nSubtypes may have a symmetry (such as PlaneSource) and will contain information about physical medium.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.PlaneSource","page":"Base","title":"MultipleScattering.PlaneSource","text":"PlaneSource(medium::P, amplitude::SVector, wavevector::SVector)\n\nIs a struct type which describes a plane-wave source that drives/forces the whole system. It has three fields: a physical medium, an amplitude of the source, and the direction the propagate in wavevector.\n\nFor any given angular frequency ω, the PlaneSource has the value e^i ωc mathbf v cdot mathbf x  at the point mathbf x, where c is the medium wavespeed and mathbf v is the wavevector.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.Source","page":"Base","title":"MultipleScattering.Source","text":"Source(medium::P, field::Function, coef::Function)\n\nIs a struct type which describes the source field that drives/forces the whole system. It is also described as an incident wave. It has three fields Source.medium, Source.field, and Source.coef.\n\nThe source field at the position 'x' and angular frequency 'ω' is given by\n\nx = [1.0,0.0]\nω = 1.0\nSource.field(x,ω)\n\nThe field Source.coef regularbasisfunction(medium::Acoustic{T,2}, ω::T)\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.self_test-Union{Tuple{Source{T,P}}, Tuple{T}, Tuple{P}} where T where P","page":"Base","title":"MultipleScattering.self_test","text":"Check that the source functions return the correct types\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.source_expand-Union{Tuple{T}, Tuple{P}, Tuple{Source{T,P},AbstractArray{T,1}}} where T where P","page":"Base","title":"MultipleScattering.source_expand","text":"source_expand(Source, centre; basis_order = 4)\n\nReturns a function of (x,ω) which approximates the value of the source at (x,ω). That is, the source is written in terms of a regular basis expansion centred at centre.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#impulse_base-1","page":"Base","title":"Impulse","text":"","category":"section"},{"location":"library/base/#","page":"Base","title":"Base","text":"Impulse types and functions.","category":"page"},{"location":"library/base/#","page":"Base","title":"Base","text":"Modules = [MultipleScattering]\nOrder   = [:type, :function]\nPages   = [\"src/impulse.jl\", \"src/time_simulation.jl\"]","category":"page"},{"location":"library/base/#MultipleScattering.ContinuousImpulse","page":"Base","title":"MultipleScattering.ContinuousImpulse","text":"See also: DiscreteImpulse, frequency_to_time\n\nContinuousImpulse{T<:AbstractFloat}\n\nA struct used to represnt analytic impulse functions. Has two fields: in_time a function of time t, and in_freq a function of the angular frequency ω. in_freq should be the Fourier transform of in_time, though this is not enforced.\n\nWe use the Fourier transform convention: F(ω) =  ∫ f(t)exp(imωt) dt, f(t) = (2π)^(-1) * ∫ F(ω)exp(-imωt) dω.\n\nAn impluse f(t) is convoluted in time with the field u(t), however we avoid the convlution by working with the fourier transform F(ω) of the impulse f(t), which results in\n\nfrequency to time: (2π)^(-1) * ∫ F(ω)U(ω)exp(-imωt) dω\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.DiscreteImpulse","page":"Base","title":"MultipleScattering.DiscreteImpulse","text":"See also: ContinuousImpulse, frequency_to_time, DiscreteGaussianImpulse\n\nDiscreteImpulse{T<:AbstractFloat}\n\nA struct used to represent a numerical impulse. Only the fields: in_freq which is the frequency response vector, and the frequency vector ω are required to use this struct to use in the function frequency_to_time.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.DiscreteGaussianImpulse-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}, Tuple{AbstractArray{T,N} where N,AbstractArray{T,N} where N}} where T","page":"Base","title":"MultipleScattering.DiscreteGaussianImpulse","text":"See also: ContinuousImpulse, TimeDiracImpulse\n\nDiscreteGaussianImpulse(t_vec[, ω_vec])\n\nReturns a discretised gaussian impulse.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.FreqDiracImpulse-Union{Tuple{T}, Tuple{T}, Tuple{T,T}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.FreqDiracImpulse","text":"Dirac Delta function of unit area in the frequency domain centred at ω=ω0.\n\nWarning: in frequency space this is a singuarity and so may lead to unexpected behaviour.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.GaussianImpulse-Union{Tuple{T}, Tuple{T}, Tuple{T,T}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.GaussianImpulse","text":"See also: ContinuousImpulse, TimeDiracImpulse\n\nGaussianImpulse(maxω[, a = 3.0/maxω^2])\n\nReturns a gaussian impulse function, which in the frequency domain is exp(-aω^2)(2sqrt(a*pi)).\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.TimeDiracImpulse-Union{Tuple{T}, Tuple{T}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.TimeDiracImpulse","text":"TimeDiracImpulse(t0::T)\n\nDirac Delta function of unit area in the time domain centred at t=t0.\n\nWarning: in the time domain this is a singuarity and so may lead to unexpected behaviour.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.self_test-Union{Tuple{ContinuousImpulse{T}}, Tuple{T}} where T","page":"Base","title":"MultipleScattering.self_test","text":"Check that the continuous impulse functions return the correct types\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.self_test-Union{Tuple{DiscreteImpulse{T}}, Tuple{T}} where T","page":"Base","title":"MultipleScattering.self_test","text":"Check that the discrete impulse vectors are the right sizes\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.firstnonzero-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.firstnonzero","text":"Returns the first element of array which isn't zero (assumes elements are increasing and distinct)\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.frequency_to_time-Union{Tuple{FrequencySimulationResult{T,Dim,FieldDim}}, Tuple{T}, Tuple{FieldDim}, Tuple{Dim}} where T where FieldDim where Dim","page":"Base","title":"MultipleScattering.frequency_to_time","text":"Convert a FrequencySimulationResult into a TimeSimulationResult by using the inverse fourier transform. Assumes only positive frequencies and a real time signal\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.frequency_to_time-Union{Tuple{T}, Tuple{AbstractArray{Complex{T},N} where N,AbstractArray{T,1}}, Tuple{AbstractArray{Complex{T},N} where N,AbstractArray{T,1},AbstractArray{T,N} where N}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.frequency_to_time","text":"See also: DiscreteImpulse, ContinuousImpulse\n\nCalculates the time response from the frequency response by approximating an inverse Fourier transform. The time signal is assumed to be real and the frequenices ω_vec are assumed to be positive (can include zero) and sorted. The result is convoluted in time ωith the user specified impulse.\n\nWe use the Fourier transform convention: F(ω) =  ∫ f(t)exp(imωt) dt f(t) = (2π)^(-1) * ∫ F(ω)exp(-imωt) dt\n\nTo easily sample any time, the default is not FFT, but a discrete version of the transform above.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.t_to_ω-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.t_to_ω","text":"The inverse of ωtot if ω_vec[1] == 0\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.time_to_frequency-Union{Tuple{TimeSimulationResult{T,Dim,FieldDim}}, Tuple{T}, Tuple{FieldDim}, Tuple{Dim}} where T where FieldDim where Dim","page":"Base","title":"MultipleScattering.time_to_frequency","text":"Convert a TimeSimulationResult into a FrequencySimulationResult by using the fourier transform. Assumes only positive frequencies and a real time signal\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.time_to_frequency-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,AbstractArray{T,1}}, Tuple{AbstractArray{T,N} where N,AbstractArray{T,1},AbstractArray{T,N} where N}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.time_to_frequency","text":"The inverse of the function frequencytotime (only an exact inverse when using :dft integration). We use the Fourier transform convention: F(ω) =  ∫ f(t)exp(imω*t) dt\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.ω_to_t-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.ω_to_t","text":"returns an array of time from the frequency array ωvec. Uses the same convention for sampling the time as the discrete Fourier transfrom. Assumes ωvec is ordered and non-negative.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#simulation_base-1","page":"Base","title":"Simulation","text":"","category":"section"},{"location":"library/base/#","page":"Base","title":"Base","text":"Simulation types and functions.","category":"page"},{"location":"library/base/#","page":"Base","title":"Base","text":"FrequencySimulation\nrun(::FrequencySimulation)\nrun(::FrequencySimulation, ::Shape, ::AbstractVector)\nFrequencySimulationResult\nbasis_coefficients\nfield\nscattering_matrix\nt_matrix\nget_t_matrices","category":"page"},{"location":"library/base/#MultipleScattering.FrequencySimulation","page":"Base","title":"MultipleScattering.FrequencySimulation","text":"FrequencySimulation([particles::AbstractParticles=[],]\n                    source::Source)\n\nBuild a FrequencySimulation. If particles are not provided, an empty array is used.\n\nAfter building, you can run the simulation to get a FrequencySimulationResult.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#Base.run-Tuple{FrequencySimulation}","page":"Base","title":"Base.run","text":"run(sim::FrequencySimulation, x, ω; basis_order=5)\n\nRun the simulation sim for the position x and angular frequency ω.\n\nPosition can be an SVector or Vector{SVector} and frequency can be a float or vector of floats.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#Base.run-Tuple{FrequencySimulation,Shape,AbstractArray{T,1} where T}","page":"Base","title":"Base.run","text":"run(sim::FrequencySimulation, rectangle;\n    res=20, xres=res, yres=res, basis_order=5)\n\nRun the simulation sim for a grid of positions in rectangle and for angular frequency ω.\n\nFrequency can be a float or vector of floats. The resolution of the grid points is defined by xres and yres.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.FrequencySimulationResult","page":"Base","title":"MultipleScattering.FrequencySimulationResult","text":"Struct to hold results of a FrequencySimulation\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.basis_coefficients","page":"Base","title":"MultipleScattering.basis_coefficients","text":"basis_coefficients(sim::FrequencySimulation, ω::AbstractFloat; basis_order::Int=5)::Matrix{Complex}\n\nReturn coefficients for bases around each particle for a given simulation and angular frequency (ω).\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.field","page":"Base","title":"MultipleScattering.field","text":"field(result::SimulationResult, [i::Integer, j::Integer])\n\nGet field from result, optionally specifying indices.\n\nReturns single value of/matrix of complex SVectors() if vector field, and complex float if scalar field.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.scattering_matrix","page":"Base","title":"MultipleScattering.scattering_matrix","text":"Create the matrix S which will be inverted to find the scattering coefficients. Currently assumes 2D.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.t_matrix","page":"Base","title":"MultipleScattering.t_matrix","text":"t_matrix(particle, medium, ω, order)\n\nReturns a finite T-matrix, with size depending on order, for a specific particle within a medium with specific physical properties.\n\n\n\n\n\nt_matrix(Particle{T,2,Acoustic{T,2},Circle{T}}, Acoustic{T,2}, ω, order)\n\nThe T-matrix for a 2D circlular acoustic particle in a 2D acoustic medium.\n\n\n\n\n\nt_matrix(CapsuleParticle{T,2,Acoustic{T,2},Circle{T}}, Acoustic{T,2}, ω, order)\n\nThe T-matrix for a 2D circlular capsule particle in an acoustic medium.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.get_t_matrices","page":"Base","title":"MultipleScattering.get_t_matrices","text":"Returns vector of T-matrices from a vector of particles in a specific domain. Can save computation if multiple of the same kind of particle are present in the vector.\n\n\n\n\n\n","category":"function"},{"location":"example/moments/README/#StatisticalMoments-1","page":"StatisticalMoments","title":"StatisticalMoments","text":"","category":"section"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"DocTestSetup = quote\n    using MultipleScattering\nend","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"Here we are going to simulate the scattered wave for many different configurations of particles. We can then take the average and standard deviation (the moments) of the scattered wave. In statistical mechanics this process is called ensemble average.","category":"page"},{"location":"example/moments/README/#Region-and-particles-properties-1","page":"StatisticalMoments","title":"Region and particles properties","text":"","category":"section"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"First we choose the region to place particles and the receiver position:","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"bottomleft = [0.0;-25.0]\ntopright = [50.0;25.0]\nshape = Rectangle(bottomleft, topright)\nx = [-10.0,0.0]","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"using Plots\nplot(shape);\nscatter!([x[1]],[x[2]], label=\"\");\nplot_shape = annotate!([(x[1], x[2] -2., \"Receiver\")])","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"(Image: Plot of shape and receiver)","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"Next we fill this shape with a random (uniform distribution) configuration of particles:","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"volfrac = 0.05\nradius = 1.0\n\nparticles = random_particles(Acoustic(2; ρ=0.0, c=0.0), Circle(radius);\n        region_shape = shape,\n        volume_fraction = volfrac,\n        seed=2\n);\n\ntypeof(particles)\n\n# output\nArray{AbstractParticle{Float64,2},1}","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"To see the position of the chosen particles:","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"plot(plot_shape)\nplot!(particles);\nplot!()","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"(Image: Plot particles)","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"Scattering a plane-wave from these particles  ","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"ωs = LinRange(0.01,1.0,100)\nplane_wave = plane_source(Acoustic(1.0, 1.0, 2);\n    direction = [1.0,0.0], position = x);\nsim = FrequencySimulation(particles, plane_wave);","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"plot(run(sim,x,ωs))","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"(Image: )","category":"page"},{"location":"example/moments/README/#The-moments-of-the-scattered-wave-1","page":"StatisticalMoments","title":"The moments of the scattered wave","text":"","category":"section"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"Now we will do simulations for particles placed in many different configurations and take the moments:","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"results = map(1:20) do i\n    particles = random_particles(Acoustic(2; ρ=0.0, c=0.0), Circle(radius);\n            region_shape = shape,\n            volume_fraction = volfrac,\n            seed=i\n    )\n    run(FrequencySimulation(particles, plane_wave), x, ωs)\nend\n\n# package Plots changed it's argument, the below no longer works..\n# num_moments = 3\n# plot(results; field_apply = real, num_moments = num_moments)\n# plot!(xlabel=\"wavenumbers\", title=\"Moments of the real part\")","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"(Image: Moments of the real part the scattered waves)","category":"page"},{"location":"example/moments/README/#Calculate-the-moments-of-the-scattered-wave-in-time-1","page":"StatisticalMoments","title":"Calculate the moments of the scattered wave in time","text":"","category":"section"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"time_simulations = frequency_to_time.(results)\ntime_simulations[1].t # the time_arr chosen will be based on the discrete Fourier transform of simulations[1].k_arr\n# real_time_moments = StatisticalMoments(time_simulations; response_apply=real) # moments of the real part\n# plot(real_time_moments,xlims=(0,300));\n# plot!(xlabel=\"time\", title=\"Moments of the real part of the time wave\")","category":"page"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"(Image: Moments of the real part the scattered waves in time)","category":"page"},{"location":"example/moments/README/#References-1","page":"StatisticalMoments","title":"References","text":"","category":"section"},{"location":"example/moments/README/#","page":"StatisticalMoments","title":"StatisticalMoments","text":"A. L. Gower, R. M. Gower, J. Deakin, W. J. Parnell, I. D. Abrahams, Learning about random media from near-surface backscattering: using machine learning to measure particle size and concentration, arXiv preprint, (2018)1801.05490","category":"page"},{"location":"manual/plot/#Plotting-1","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"manual/plot/#","page":"Plotting","title":"Plotting","text":"The plotting for this package is supplied by the package Plots. The options and keywords used for the package Plots can be used for the plots in this package.","category":"page"},{"location":"manual/plot/#","page":"Plotting","title":"Plotting","text":"Below are examples of plotting the whole field in frequency (harmonic wave) and time. The examples require the package Plots and, mostly, PyPlot.","category":"page"},{"location":"manual/plot/#Field-Harmonic-two-gaps-1","page":"Plotting","title":"Field - Harmonic two gaps","text":"","category":"section"},{"location":"manual/plot/#","page":"Plotting","title":"Plotting","text":"using MultipleScattering\nusing Plots; pyplot(size = (800,300))\n\nradius = 1\nω = 2.0\n\nhost_medium = Acoustic(1.0, 1.0, 2)\nparticle_medium = Acoustic(0.0, 0.0, 2)\n\n# Create a wall of particles\nparticles = [\n  Particle(particle_medium, Circle([0.,y],1.0))\nfor y = -40:2*radius:40.]\n\n# Make two gaps in the wall\ndeleteat!(particles,[18,19,23,24])\n\n# Define region to plot\nbottomleft = [-10.;-15.]\ntopright = [30.;15.]\nregion = Rectangle(bottomleft, topright)\n\n# Calculating scattering for a plane wave\nsource =  plane_source(host_medium; direction = [1.0,0.0])\n\n# You can skip the step of defining FrequencySimulation\nresult = run(particles, source, region, [ω]; res=100)\n\nplot(result,ω;\n    field_apply = abs, seriestype = :contour,\n    title = \"Absolute value\"\n  );\np1 = plot!(particles, ylims = (-15.0,15.0));  \nplot(result,ω;\n    field_apply = real, seriestype = :contour,\n    title = \"Real part\"\n);\np2 = plot!(particles, ylims = (-15.0,15.0));\nplot(p1, p2)\n\n# savefig(\"gap-diffraction.png\")","category":"page"},{"location":"manual/plot/#","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"manual/plot/#Movie-Harmonic-two-gaps-1","page":"Plotting","title":"Movie - Harmonic two gaps","text":"","category":"section"},{"location":"manual/plot/#","page":"Plotting","title":"Plotting","text":"Continuing from Field - Harmonic two gaps, the previous example, we can plot how the harmonic field oscillates in time. That is, to get the harmonic field at time t we just multiple the field by mathrm e^-mathrm i omega t for every mathbf x. For example, the plane wave mathrm e^mathrm i x k would become mathrm e^mathrm i x k -mathrm i omega t.   ","category":"page"},{"location":"manual/plot/#","page":"Plotting","title":"Plotting","text":"pyplot(size = (450,300))\n\nts = LinRange(0.,2pi/ω,30)\n\nmaxc = round(10*maximum(real.(field(result))))/10\nminc = round(10*minimum(real.(field(result))))/10\n\nanim = @animate for t in ts\n    plot(result,ω; seriestype = :contour,\n        phase_time=t, clim=(minc,maxc),\n        ylims = (-15.0,15.0) , c=:balance\n    )\n    plot!(particles)\n    plot!(colorbar=false, title=\"\",axis=false, xlab=\"\",ylab=\"\")\nend\n# gif(anim,\"gap-diffraction.gif\", fps = 7)","category":"page"},{"location":"manual/plot/#","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"manual/plot/#Movie-Time-impulse-plane-wave-two-gaps-1","page":"Plotting","title":"Movie - Time impulse plane-wave - two gaps","text":"","category":"section"},{"location":"manual/plot/#","page":"Plotting","title":"Plotting","text":"Continuing from Field - Harmonic two gaps, we can plot how an impulse plave-wave in time passes through two gaps. See Time response for more details on the code used below.","category":"page"},{"location":"manual/plot/#","page":"Plotting","title":"Plotting","text":"pyplot(size = (450,300))\nωs = LinRange(0.0,2.0,300)[2:end] # avoid using ω = 0\n\n# We use a lower resolution (res = 50) as this is a heavier calculation\nresult = run(particles, source, region, ωs; res = 50)\n\n# Calculate time response over rect\nt_max = 0.75 .* real(region.width / host_medium.c)\nts = LinRange(0.0,t_max,75)\nimpulse = GaussianImpulse(maximum(ωs)*0.6)\ntimres = frequency_to_time(result; t_vec = ts, impulse = impulse)\n\nmaxc = round(10*maximum(field(timres)))/10\nminc = round(10*minimum(field(timres)))/10\n\n# timres = TimeSimulationResult(timres.field .+ max_c/100.0 , timres.x, timres.t)\n\nylims =  (-region.height/2,region.height/2)\nanim = @animate for t in ts\n    plot(timres,t,seriestype=:contour,\n      clim = (minc, maxc),\n      leg = false, ylims = ylims\n    )\n    plot!(particles)\n    plot!(frame = :none, title=\"\", xlab=\"\",ylab=\"\")\nend\n\n# gif(anim,\"gap-diffraction.gif\", fps = 7)","category":"page"},{"location":"manual/plot/#","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"manual/plot/#Movie-Harmonic-from-random-particles-1","page":"Plotting","title":"Movie - Harmonic from random particles","text":"","category":"section"},{"location":"manual/plot/#","page":"Plotting","title":"Plotting","text":"using MultipleScattering\nusing Plots; pyplot()\n\nnum_particles = 70\nradius = 1.0\nω = 1.0\n\nhost_medium = Acoustic(1.0, 1.0, 2)\nparticle_medium = Acoustic(0.2, 0.3, 2)\nparticle_shape = Circle(radius)\n\nmax_width = 50*radius\nbottomleft = [0.,-max_width]\ntopright = [max_width,max_width]\nshape = Rectangle(bottomleft,topright)\n\nparticles = random_particles(particle_medium, particle_shape; region_shape = shape, num_particles = num_particles)\n\nsource =  plane_source(host_medium; direction = [1.0,0.5])\n\nsimulation = FrequencySimulation(particles, source)\n\nbottomleft = [-25.,-max_width]\nbounds = Rectangle(bottomleft,topright)\nresult = run(simulation, bounds, [ω]; res=100)\n\nts = LinRange(0.,2pi/ω,30)\n\nmaxc = round(10*maximum(real.(field(result))))/10\nminc = round(10*minimum(real.(field(result))))/10\n\nanim = @animate for t in ts\n    plot(result,ω; seriestype = :contour, phase_time=t, clim=(minc,maxc), c=:balance)\n    plot!(simulation)\n    plot!(colorbar=false, title=\"\",axis=false, xlab=\"\",ylab=\"\")\nend\n# gif(anim,\"backscatter_harmonic.gif\", fps = 7)","category":"page"},{"location":"manual/plot/#","page":"Plotting","title":"Plotting","text":"(Image: backscattering from harmonic wave)","category":"page"},{"location":"example/time_response_single_particle/README/#Time-response-from-single-particle-1","page":"Time response from single particle","title":"Time response from single particle","text":"","category":"section"},{"location":"library/acoustics/#Acoustic-1","page":"Acoustic","title":"Acoustic","text":"","category":"section"},{"location":"library/acoustics/#","page":"Acoustic","title":"Acoustic","text":"CurrentModule = MultipleScattering","category":"page"},{"location":"library/acoustics/#","page":"Acoustic","title":"Acoustic","text":"Acoustic type and functions.","category":"page"},{"location":"library/acoustics/#","page":"Acoustic","title":"Acoustic","text":"Modules = [MultipleScattering]\nOrder   = [:constant, :type, :function]\nPages   = [\"acoustics/acoustics.jl\",\"acoustics/circle.jl\",\"acoustics/concentric_capsule.jl\",\"acoustics/source.jl\"]","category":"page"},{"location":"library/acoustics/#MultipleScattering.Acoustic","page":"Acoustic","title":"MultipleScattering.Acoustic","text":"Acoustic{T<:AbstractFloat,Dim}(ρ::T, c::Complex{T})\nAcoustic(ρ::T, c::Union{T,Complex{AbstractFloat}}, Dim::Integer)\n\nPhysical properties for a homogenous isotropic acoustic medium with wavespeed (c) and density (ρ)\n\nSimulations in this medium produce scalar (1D) fields in Dim dimensions.\n\n\n\n\n\n","category":"type"},{"location":"library/acoustics/#MultipleScattering.hard-Union{Tuple{Acoustic{T,Dim}}, Tuple{Dim}, Tuple{T}} where Dim where T","page":"Acoustic","title":"MultipleScattering.hard","text":"hard(host_medium::Acoustic)\n\nSee sound_hard.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.impedance-Tuple{Acoustic}","page":"Acoustic","title":"MultipleScattering.impedance","text":"impedance(medium::Acoustic)\n\nCharacteristic specific acoustic impedance (z₀) of medium\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.pressure_release-Union{Tuple{Acoustic{T,Dim}}, Tuple{Dim}, Tuple{T}} where Dim where T","page":"Acoustic","title":"MultipleScattering.pressure_release","text":"pressure_release(host_medium::Acoustic)\n\nSee sound_soft.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.regular_basis_function-Union{Tuple{T}, Tuple{Acoustic{T,2},T}} where T","page":"Acoustic","title":"MultipleScattering.regular_basis_function","text":"Basis function when inside a particle. Assumes particle is a circle, which approximately works for all shapes.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.rigid-Union{Tuple{Acoustic{T,Dim}}, Tuple{Dim}, Tuple{T}} where Dim where T","page":"Acoustic","title":"MultipleScattering.rigid","text":"rigid(host_medium::Acoustic)\n\nSee sound_hard.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.soft-Union{Tuple{Acoustic{T,Dim}}, Tuple{Dim}, Tuple{T}} where Dim where T","page":"Acoustic","title":"MultipleScattering.soft","text":"soft(host_medium::Acoustic)\n\nSee sound_soft.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.sound_hard-Tuple{Type,Integer}","page":"Acoustic","title":"MultipleScattering.sound_hard","text":"sound_hard([T::Type = Float64,] Dim::Integer)\n\nConstruct physical properties of a sound hard acoustic object with type T and dimension Dim. Also known as rigid and equivalent to a zero_neumann pressure boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.sound_soft-Tuple{Type,Integer}","page":"Acoustic","title":"MultipleScattering.sound_soft","text":"sound_soft([T::Type = Float64,] Dim::Integer)\n\nConstruct physical properties of a sound hard acoustic object with type T and dimension Dim. Equivalent to a zero_dirichlet pressure boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.zero_dirichlet-Union{Tuple{Acoustic{T,Dim}}, Tuple{Dim}, Tuple{T}} where Dim where T","page":"Acoustic","title":"MultipleScattering.zero_dirichlet","text":"zero_dirichlet(host_medium::Acoustic)\n\nSee sound_soft.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.zero_neumann-Union{Tuple{Acoustic{T,Dim}}, Tuple{Dim}, Tuple{T}} where Dim where T","page":"Acoustic","title":"MultipleScattering.zero_neumann","text":"zero_neumann(host_medium::Acoustic)\n\nSee sound_hard.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.internal_field-Union{Tuple{T}, Tuple{SArray{Tuple{2},T,1,2},Particle{T,2,Acoustic{T,2},Circle{T}},FrequencySimulation{T,2,Acoustic{T,2}},T,AbstractArray{Complex{T},1}}} where T","page":"Acoustic","title":"MultipleScattering.internal_field","text":"internal_field(x::SVector{2,T}, p::Particle{T,2,Acoustic{T,2},Circle{T}}, sim::FrequencySimulation{T,2,Acoustic{T,2}}, ω::T, scattering_coefficients::AbstractVector{Complex{T}})\n\nThe internal field for a 2D circlular acoustic particle in a 2D acoustic medium.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.t_matrix-Union{Tuple{T}, Tuple{Particle{T,2,Acoustic{T,2},Circle{T}},Acoustic{T,2},T,Integer}} where T<:AbstractFloat","page":"Acoustic","title":"MultipleScattering.t_matrix","text":"t_matrix(Particle{T,2,Acoustic{T,2},Circle{T}}, Acoustic{T,2}, ω, order)\n\nThe T-matrix for a 2D circlular acoustic particle in a 2D acoustic medium.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.t_matrix-Union{Tuple{T}, Tuple{CapsuleParticle{T,2,Acoustic{T,2},Circle{T}},Acoustic{T,2},T,Integer}} where T<:AbstractFloat","page":"Acoustic","title":"MultipleScattering.t_matrix","text":"t_matrix(CapsuleParticle{T,2,Acoustic{T,2},Circle{T}}, Acoustic{T,2}, ω, order)\n\nThe T-matrix for a 2D circlular capsule particle in an acoustic medium.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.plane_source-Union{Tuple{T}, Tuple{Acoustic{T,2},Any}, Tuple{Acoustic{T,2},Any,Any}, Tuple{Acoustic{T,2},Any,Any,Union{Complex{T}, T}}} where T","page":"Acoustic","title":"MultipleScattering.plane_source","text":"plane_source(medium::Acoustic, source_position, source_direction=[1,0], amplitude=1)::Source\n\nCreate 2D Acoustic planar wave Source\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.point_source-Union{Tuple{T}, Tuple{Acoustic{T,2},Any}, Tuple{Acoustic{T,2},Any,Union{Complex{T}, Function, T}}} where T<:AbstractFloat","page":"Acoustic","title":"MultipleScattering.point_source","text":"point_source(medium::Acoustic, source_position, amplitude=1)::Source\n\nCreate 2D Acoustic point Source (zeroth Hankel function of first type)\n\n\n\n\n\n","category":"method"},{"location":"manual/source/#Sources-1","page":"Sources","title":"Sources","text":"","category":"section"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"DocTestSetup = quote\n    using MultipleScattering\nend","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"Source is a struct which represents any source, also called an incident wave. For acoustics, any wave field u_textin(xy) that satisfies nabla^2 u_textin(xy) + k^2 u_textin(xy) = 0, with k = omegac, can be a source. See Source for a list of relevant types and functions.","category":"page"},{"location":"manual/source/#D-Acoustics-1","page":"Sources","title":"2D Acoustics","text":"","category":"section"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"Two common source waves are shown below.","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"For a plane-wave of the form u_textin(xy) = A mathrm e^mathrm i k mathbf n cdot (mathbf x - mathbf x_0), where A is the amplitude, mathbf n = (n_1n_2) is the direction of propagation, and mathbf x_0 = (x_0y_0) is the initially position of the source, we can use","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"julia> medium = Acoustic(1.0, 1.0, 2);\n\njulia> A = 1.0;\n\njulia> n = [1.0,1.0];\n\njulia> x0 = [1.0,0.0];\n\njulia> plane_wave = plane_source(medium; amplitude = A, direction = n, position = x0);","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"We can plot this source wave one frequency ω by using","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"julia> ω = 1.0;\n\njulia> domain = Rectangle([-1.0,-1.0],[1.0,1.0]);\n\njulia> plot(plane_wave, ω; bounds = domain)","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"(Image: Plot plane wave)","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"Another useful source is the point source u_textin(xy) = fracmathrm i A4 mathrm H_0^(1)(k (x-x_0y-y_0)) where A is the amplitude,  mathbf x_0 = (x_0y_0) is the origin of the point source, and mathrm H_0^(1) is the Hankel function of the first kind.","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"julia> x0 = [0.0,-1.2];\n\njulia> domain = Rectangle([-1.0,-1.0],[1.0,1.0]);\n\njulia> point_wave = point_source(medium, x0, A);","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"julia> plot(point_wave, ω; bounds = domain)","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"(Image: Plot point wave)","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"note: Note\nBecause the point source has a singularity at x_0 it is best to avoid plotting, and evaluating the field, close to x_0.","category":"page"},{"location":"manual/source/#Creating-new-sources-1","page":"Sources","title":"Creating new sources","text":"","category":"section"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"The easiest way to create new sources is to just sum together predefined sources:","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"julia> source = (3.0 + 1.0im) * point_wave + plane_wave;\n\njulia> plot(source, ω; bounds = domain)","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"(Image: Plot point wave)","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"For example, to create a finite emitter/transducer source we can use:","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"julia> ys = LinRange(-0.7, 0.7, 30);\n\njulia> source = sum(ys) do y point_source(medium, [-1.1, y]) end;\n\njulia> plot(source, 4.0; bounds = domain, field_apply = abs, res = 40)","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"(Image: Plot point wave)","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"where field_apply is applied to the wave field at every point, the default is field_apply = real, and res is the resolution along both the x and y axis.","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"To define a new source you will need to understand the internals below.","category":"page"},{"location":"manual/source/#Source-internals-1","page":"Sources","title":"Source internals","text":"","category":"section"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"The struc Source has three fields: medium, field, and coef, explained with examples below:","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"julia> plane_wave = plane_source(Acoustic(1.0, 1.0, 2); direction = [1.0,0.0]);\n\njulia> plane_wave.medium # the physical medium\nAcoustic(1.0, 1.0 + 0.0im, 2)\n\njulia> x = [1.0,1.0]; ω = 1.0;\n\njulia> plane_wave.field(x,ω) # the value of the field\n0.5403023058681398 + 0.8414709848078965im","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"To calculate the scattering from a particle due to a source, we need the coefficients a_n(mathbf x_0 omega) =  Sourcecoef(x0ω) We use these coefficients to represent the source in a radial coordinate system That is for any origin mathbf x_0, we need to represent the incident wave u_textin(mathbf x) using a series or regular waves","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"u_textin(mathbf x) = sum_n a_n(mathbf x_0 omega) mathrm v_n(mathbf x - mathbf x_0)","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"where for the scalar wave equation:","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"mathrm v_n(mathbf x) = begincases\n   mathrm J_n(k r) mathrm e^mathrm i theta n  textfor  mathbf x in mathbb R^2 \n   mathrm j_ell(k r) mathrm Y_ell^m(hatmathbf x)  textfor  mathbf x in mathbb R^3\nendcases","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"where for the first case (rtheta) are the polar coordinates and n sums over -N-N+1 cdots N, where N is the basis order, and mathrm J_n is a Bessel function. For the second case, we use a spherical coordinates with r =  mathbf x and hatmathbf x = mathbf xmathbf x, n denotes the multi-index n=ellm with summation over ell = 0 1 cdotsN and m=-ell-ell+1ell, mathrm j_ell is a spherical Bessel function, and mathrm Y_ell^m is a spherical harmonic.","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"Both the inbuilt plane and point sources have functions coef which satisfy the above identity, for example","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"julia> using LinearAlgebra, SpecialFunctions;\n\njulia> medium = Acoustic(2.0, 0.1, 2);\n\njulia> source = plane_source(medium);\n\njulia> x0 = [1.0,1.0]; ω = 0.9;\n\njulia> x = x0 + 0.1*rand(2); basis_order = 10;\n\njulia> vs = regular_basis_function(medium, ω);\n\njulia> source.field(x,ω) ≈ sum(source.coef(basis_order,x0,ω) .* vs(basis_order, x - x0))\ntrue","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"The package also supplies a convenience function source_expand, which represents the source in terms of regular waves, for example:  ","category":"page"},{"location":"manual/source/#","page":"Sources","title":"Sources","text":"julia> source2 = source_expand(source, x0; basis_order = 10);\n\njulia> source.field(x,ω) ≈ source2(x,ω)\ntrue","category":"page"},{"location":"manual/intro/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"manual/intro/#into_physical_properties-1","page":"Introduction","title":"Physical properties wave","text":"","category":"section"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"First define the host medium, for example for an acoustic medium in 2D","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using MultipleScattering\nend","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"julia> host_medium = Acoustic(2; ρ=1.0, c=1.0) # density ρ = 1.0 and soundspeed c = 1.0\nAcoustic(1.0, 1.0 + 0.0im, 2)","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"At this step we have restricted the physics to acoustics, that is, solutions to the Helmholtz equation: nabla^2 u(xyomega) + k^2 u(xyomega) = 0, where k = omegac, omega is the angular frequency and c the sound speed of the medium.","category":"page"},{"location":"manual/intro/#into_source-1","page":"Introduction","title":"Source wave","text":"","category":"section"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"The host medium will determine the types of waves that can propagate. For example an incident plane wave mathrm e^ mathrm i k x there is a convenient constructor","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"julia> source = plane_source(host_medium; direction = [1.0,0.0]);","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"note: Note\nOften mathrm e^ mathrm i k x - mathrm i omega t is considered to be a harmonic plane-wave travelling along the x-axis. We omit the part $ - \\mathrm i \\omega t$ as is common in frequency space.  ","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"We generally call the incident wave a source. See Sources for details, and see Acoustic for some functions for the Acoustic medium.","category":"page"},{"location":"manual/intro/#into_particles-1","page":"Introduction","title":"Particles","text":"","category":"section"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"Next, we define some particles to scatter an acoustic wave. We choose two filled circles, the first centred at [-2,2] with radius 2 and the second at [-2,-2] with radius 0.5,","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"julia> particle_medium =  Acoustic(2; ρ=10.0, c=2.0); # 2D acoustic particle with density ρ = 10.0 and soundspeed c = 2.0\n\njulia> p1 = Particle(particle_medium, Circle([-2.0,2.0], 2.0))\nParticle(Acoustic(10.0, 2.0 + 0.0im, 2), Circle((-2.0, 2.0), 2.0))\n\njulia> p2 = Particle(particle_medium, Circle([-2.0,-2.0], 0.5))\nParticle(Acoustic(10.0, 2.0 + 0.0im, 2), Circle((-2.0, -2.0), 0.5))\n\njulia> particles = [p1,p2];","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"See Shapes and Particles for details on different shapes and particles.","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"If you have the package Plots installed you can plot the particles. Note that although they appear hollow, we consider them to filled with the same homogenous material.","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"julia> using Plots; pyplot();\n\njulia> plot(particles);","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"note: Note\nMost things in this package can be plotted just by typing plot(thing). However you need to have Plots installed, and you may need to use the backend pyplot(). See Plotting for details on plotting.","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"(Image: Plot of response against wavenumber)","category":"page"},{"location":"manual/intro/#Simulation-and-results-1","page":"Introduction","title":"Simulation and results","text":"","category":"section"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"Once we know the medium, the particles, and the have these three components, we can build our FrequencySimulation object","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"julia> simulation = FrequencySimulation(particles, source);","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"To get numerical results, we run our simulation for specific positions and angular frequencies,","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"julia> x = [[-10.0,0.0], [0.0,0.0]];\n\njulia> max_ω = 1.0;\n\njulia> ωs = 0.01:0.01:max_ω;\n\njulia> result = run(simulation, x, ωs);","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"We can plot the time-harmonic response across the frequencies ωs wavenumbers and at the location (-10,0) by typing:","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"julia> plot(result)","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"(Image: Plot of response against wavenumber)","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"For a better overview you can calculate the response for lots of points x in the domain and then plot the whole field for one frequency ω by typing:","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"julia> ω = 0.8;\n\njulia> plot(simulation, ω);\n\njulia> plot!(particles)","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"(Image: Plot real part of acoustic field)","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"For details on plot fields and videos see Plotting.","category":"page"},{"location":"manual/intro/#Results-in-time-1","page":"Introduction","title":"Results in time","text":"","category":"section"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"If we have calculated a frequency response hat u(omega) over a range of frequencies omega, then we can use a Fourier transform to calculate the response in time u(t). That is, we can calculate u(t) by approximating the Fourier transform:","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"u(t) = frac12pi int_-infty^infty hat u(omega)mathrm e^-mathrm i omega t domega","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"For details see the section on Time response. For example, taking a Discrete Fourier transform of the previous response leads to an incident plane wave pulse in time:","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"julia> time_result = frequency_to_time(result);\n\njulia> plot(time_result)","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"(Image: Plot real part of acoustic field)","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"In the image above the first peak on the left is due to the incident wave (the source), and the second peak is the wave scattered by theparticles. Note how both peaks are quite jagged. This is due to Gibb's phenomena. To resolve this we can use a Gaussian impulse function shown below. See Time response for more details.","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"julia> t_vec = LinRange(0.,700.,400);\n\njulia> gauss_time_result = frequency_to_time(result; t_vec = t_vec, impulse = GaussianImpulse(max_ω));\n\njulia> plot(gauss_time_result)","category":"page"},{"location":"manual/intro/#","page":"Introduction","title":"Introduction","text":"(Image: Plot real part of acoustic field)","category":"page"},{"location":"example/README/#Overview-1","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"example/README/#[Simple-random-particles](random_particles/README.md)-1","page":"Overview","title":"Simple random particles","text":"","category":"section"},{"location":"example/README/#","page":"Overview","title":"Overview","text":"Simple example of random particles in rectangle","category":"page"},{"location":"example/README/#[Random-particles-in-a-circle](particles_in_circle/README.md)-1","page":"Overview","title":"Random particles in a circle","text":"","category":"section"},{"location":"example/README/#","page":"Overview","title":"Overview","text":"Generate random particles in a circle","category":"page"},{"location":"example/README/#[StatisticalMoments](moments/README.md)-1","page":"Overview","title":"StatisticalMoments","text":"","category":"section"},{"location":"example/README/#","page":"Overview","title":"Overview","text":"How to extract statistical information from a batch of simulations, in this case: mean, standard deviation, skew and kurtosis (also known as moments).","category":"page"},{"location":"example/README/#[Near-surface-backscattering](near_surface_backscattering/README.md)-1","page":"Overview","title":"Near surface backscattering","text":"","category":"section"},{"location":"example/README/#","page":"Overview","title":"Overview","text":"A method to calculate the backscattering from an infinite halfspace.\nSee backscattering in frequency and time.","category":"page"},{"location":"manual/new_types/#New-particles-1","page":"New particles","title":"New particles","text":"","category":"section"},{"location":"manual/new_types/#","page":"New particles","title":"New particles","text":"If you are feeling very adventurous, you can define a new type of particle.","category":"page"},{"location":"manual/new_types/#","page":"New particles","title":"New particles","text":"A particle is define by its shape and physical properties. The simplest example being a circular acoustics particle: Particle(Acoustic(1.0,1.0,2),Circle(1.0)). To define a new particle you need to either use a new shape or a new physical medium.","category":"page"},{"location":"manual/new_types/#New-shape-1","page":"New particles","title":"New shape","text":"","category":"section"},{"location":"manual/new_types/#","page":"New particles","title":"New particles","text":"Suppose we want to define a new shape, which is very much like a rectangle.","category":"page"},{"location":"manual/new_types/#","page":"New particles","title":"New particles","text":"using MultipleScattering\n\nstruct MyRectangle{T} <: Shape{T,2}\n    origin::Vector{T}\n    width::T\n    height::T\nend","category":"page"},{"location":"manual/new_types/#","page":"New particles","title":"New particles","text":"To be able to place particles in MyRectangle you need to extend the functions defined in the package you need to explicitly import them:","category":"page"},{"location":"manual/new_types/#","page":"New particles","title":"New particles","text":"import MultipleScattering: volume, name, bounding_rectangle\n\nvolume(shape::MyRectangle) = shape.width * shape.height\nname(shape::MyRectangle) = \"MyRectangle\"\n\n# every shape needs a bounding rectangle, this is where particles are first placed.\nbounding_rectangle(shape::MyRectangle) = Rectangle(shape.origin, shape.width, shape.height)\n\nimport Base.in, Base.issubset\nfunction in(x::AbstractVector, r::MyRectangle)::Bool\n    all(abs.(x .- r.origin) .<= [r.width, r.height])\nend\n\nfunction issubset(circle::Circle{T}, r::MyRectangle{T}) where {T}\n    all((origin(circle) .- circle.radius) .>= r.origin - [r.width/2.0, r.height/2.0]) &&\n    all((origin(circle) .+ circle.radius) .<= r.origin + [r.width/2.0, r.height/2.0])\nend","category":"page"},{"location":"manual/new_types/#","page":"New particles","title":"New particles","text":"note: Note\nUsing other packages with MultipleScattering may result in a naming conflict for functions like volume. In this case you will have to explicitly call MultipleScattering.volume.","category":"page"},{"location":"manual/new_types/#","page":"New particles","title":"New particles","text":"With these definitions you can now fill this shape with circular particles, as shown in Placing particles in a region.","category":"page"},{"location":"manual/new_types/#","page":"New particles","title":"New particles","text":"To define a new particle from MyRectangle you need to extend the functions outer_radius, Base.(==), iscongruent, then supposing you will use a predefined PhysicalProperty (such as Acoustic), you then need to extend t_matrix.","category":"page"},{"location":"#MultipleScattering.jl-Documentation-1","page":"Home","title":"MultipleScattering.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia library for simulating, processing, and plotting multiple scattering of acoustic waves.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The library uses the multipole method to solve the Helmholtz equation (time-harmonic waves). The multipole method is particularly efficient at solving scattering problems for particles in an infinite domain. This library is configured to use T-matrices to represent scattering from particles with any shape and properties. The package is setup to deal with different spatial dimensions and types of waves which satisfy Helmholtz equation's, e.g. acoustics, electromagnetism, elasticity. For details on some of the maths see Martin (1995) and Gower et al. (2017).","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Install Julia v1.0 or later, then run","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg\nPkg.clone(\"https://github.com/jondea/MultipleScattering.jl.git\")\nusing MultipleScattering","category":"page"},{"location":"#Manual-1","page":"Home","title":"Manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"You can learn to use this package through examples or through our manual, which starts with a simple Introduction.","category":"page"},{"location":"#Contents-1","page":"Home","title":"Contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"base.md\", \"acoustics.md\",\"random.md\"]\nDepth = 2","category":"page"},{"location":"library/random/#Random-1","page":"Random","title":"Random","text":"","category":"section"},{"location":"library/random/#","page":"Random","title":"Random","text":"CurrentModule = MultipleScattering","category":"page"},{"location":"library/random/#Random-particles-1","page":"Random","title":"Random particles","text":"","category":"section"},{"location":"library/random/#","page":"Random","title":"Random","text":"random_particles","category":"page"},{"location":"library/random/#MultipleScattering.random_particles","page":"Random","title":"MultipleScattering.random_particles","text":"random_particles(particle_medium, particle_shapes::Vector{Shape}, region_shape, volume_fraction::Number;\n    seed=Random.make_seed())\nrandom_particles(particle_medium, particle_shape::Shape, region_shape, volume_fraction::Number;\n    seed=Random.make_seed())\nrandom_particles(particle_medium, particle_shape::Shape, region_shape, N::Integer;\n    seed=Random.make_seed())\n\nGenerate N random particles that fit inside region_shape (or fill with volume_fraction)\n\nSpecify seed to make output deterministic. Algorithm places particles unifomly randomly inside the bounding rectangle of region_shape and discards particle if it overlaps (based on outer radius) or does not lies completely in box box.\n\nWhen passing particle_shapes::Vector{Shape} we assume each element is equally likely to occur. Repeating the same shape will lead to it being placed more often.\n\n\n\n\n\n","category":"function"},{"location":"library/random/#Moments-1","page":"Random","title":"Moments","text":"","category":"section"},{"location":"library/random/#","page":"Random","title":"Random","text":"statistical_moments","category":"page"},{"location":"library/random/#MultipleScattering.statistical_moments","page":"Random","title":"MultipleScattering.statistical_moments","text":"statistical_moments(results, n; field_apply=real)::Vector{Matrix}\n\nCalculate moments up to n of results at each position and wavenumber/time, after applying field_apply.\n\n\n\n\n\n","category":"function"}]
}

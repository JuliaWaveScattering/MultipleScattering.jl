var documenterSearchIndex = {"docs":
[{"location":"manual/time_response/#Time-response","page":"Time response","title":"Time response","text":"","category":"section"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"DocTestSetup = quote\n    using MultipleScattering\nend","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"This package calculates all scattering in the frequency domain, and we call the resulting field the frequency response hat u(mathbf xomega), which satisfies nabla^2 hat u(mathbf xomega) + k^2 hat u(mathbf xomega) = 0, where k = dfracomegac. We can transform the frequency response hat u(mathbf xomega) into a time response u(mathbf xt) using a Fourier transform, where u(mathbf xt) satisfies nabla^2 u(mathbf xt) - frac1c^2  fracpartial^2partial t^2u(mathbf xt) = 0. For a minimal example see Results in time, or see Technical details for more maths.","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"note: Note\nThe package assumes the time response u(mathbf xt) is always real, this simplifies the Fourier transform.","category":"page"},{"location":"manual/time_response/#impulse_intro","page":"Time response","title":"Intro","text":"","category":"section"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"As an example, let use a plane-wave source mathrm e^mathrm i omega x and measure the response at origin of the source x = (00),","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"using MultipleScattering;\n\nplane_wave = plane_source(Acoustic(1.0, 1.0, 2); direction = [1.0, 0.0], position = [0.0, 0.0]);\nx = [[0.0, 0.0]];\nωs = LinRange(0.0, 1.0, 100);\nfreq_response = run(plane_wave, x, ωs);\nt_vec = LinRange(-20.0, 80.0, 110);\ntime_response = frequency_to_time(freq_response; t_vec = t_vec);","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"where we specified the times t_vec to calculate time_response. If no t_vec is given, the default times would be t_vec = ω_to_t(ωs) which is the standard choice for the Discrete Fourier Transform.  ","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"Let us have a look at these responses:","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"using Plots;\n\np1 = plot(freq_response, xlims = (0, 2), ylims = (0.0, 1.5), field_apply = real);\np2 = plot(time_response);\nplot(p1, p2)","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"(Image: A discrete delta impulse)","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"Note how the time response has lobes after and before the largest signal. This is often undesirable, as we usually want signal which are compact in the time domain, i.e. zero before and after the largest signal. These lobes are called Gibbs Phenomena. They are caused by only calculating the frequency response hat u(mathbf xomega) up to omega leq 1, and then (usually), taking hat u(mathbf xomega) = 0 for omega  1 when calculating the Fourier transform.   ","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"We can alter the response, in time and frequency, by specifying an impulse function hat f(omega) which will use hat phi(mathbf x omega) = hat f(omega) u(mathbf x omega) as the frequency response. For example, we can choose hat f(omega) to smooth out the drastic drop in hat u(mathbf 0omega) when omega passes over omega = 1.","category":"page"},{"location":"manual/time_response/#Gaussian-impulse","page":"Time response","title":"Gaussian impulse","text":"","category":"section"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"The simplest way to avoid unwanted lobes (and Gibbs phenomena) is to use a Gaussian impulse function:","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"maxω = maximum(ωs);\ngauss_impulse = GaussianImpulse(maxω);\ntypeof(gauss_impulse)\n\n# output\nContinuousImpulse{Float64}","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"The argument maxω passed to GaussianImpulse will return an Gaussian impulse which will (mostly) avoid the lobes given by calculating only ω <= maxω. The Gaussian impulse in frequency and time is","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"ωs_all = -2.0:0.01:2.0;\np1 = plot(ω -> real(gauss_impulse.in_freq(ω)), ωs_all, title=\"Gaussian in frequency\");\np2 = plot(gauss_impulse.in_time, t_vec, title=\"Gaussian in time\");\nplot(p1, p2)","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"(Image: A Gaussian impulse)","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"The analytic expression for these functions are hat f(omega) = 2 sqrt3 pi  Omega^2 mathrm e^-3 (omegaOmega)^2 and f(t) = mathrm e^-(t Omega)^2  12, where we used Omega =  mathrmmaxomega.","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"To use this impulse we simply:","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"gauss_time_response = frequency_to_time(freq_response; t_vec = t_vec, impulse = gauss_impulse);\np1 = plot(time_response);\np2 = plot(gauss_time_response);\nplot(p1, p2)","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"(Image: Compare the Gaussian impulse)","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"There are still some lobes present because again freq_response only calculates ω<=1.0,  but this time the drop is much less pronounced, which we can demonstrate with a plot of hat phi(mathbf 0 omega):  ","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"φs = field(freq_response)[:] .* gauss_impulse.in_freq.(ωs);\nplot(ωs, real.(φs), title=\"Frequency response φ\")","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"(Image: Compare the Gaussian impulse)","category":"page"},{"location":"manual/time_response/#Discrete-impulse","page":"Time response","title":"Discrete impulse","text":"","category":"section"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"The only impulse the package provides is the Gaussian, both its discrete DiscreteGaussianImpulse and analytic form GaussianImpulse. But all this is not necessary to use your own defined impulse function. You only need to define an impulse sampled in frequency. For example suppose we want a triangle impulse in frequency:","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"# we need only define for ω > 0.0\ntriangle_freq(ω) = 5 - 5*ω;\n\n# we only need the sampled frequency response.\nin_freq = triangle_freq.(ωs);\n\n# as we have specified in_freq we do not need to specify in_time.\nin_time = 0.0*t_vec;\n\ndiscrete_impulse = DiscreteImpulse(t_vec, in_time, ωs, in_freq);\n\ntime_response = frequency_to_time(freq_response; t_vec = t_vec, discrete_impulse = discrete_impulse);","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"plot(time_response)","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"(Image: )","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"Alternatively, we can attempt to produce a triangle wave in the time domain, for which there is a convenient constructor:","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"triangle_time(t) = (abs(t/15) < 1) ? 1 - abs(t/15) : 0.0;\n\nin_time = triangle_time.(t_vec);\n\n# the function DiscreteImpulse below will calculate in_freq\ndiscrete_impulse = DiscreteImpulse(t_vec, in_time, ωs);\n\ntime_response = frequency_to_time(freq_response; t_vec = t_vec, discrete_impulse = discrete_impulse);\n\nplot!(time_response)","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"(Image: )","category":"page"},{"location":"manual/time_response/#lens_example","page":"Time response","title":"Lens example","text":"","category":"section"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"As an example, we will make a reflective lens out of particles. To achieve this we will place the particles into a region with the shape TimeOfFlightPlaneWaveToPoint.","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"First we choose the properties of the lens:","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"p_radius = 0.1;\nvolfrac = 0.3;\n\nx = [-10.0; 0.0];\noutertime = 34.8;\ninnertime = 34.0;\n\n# Generate particles which are at most outertime away from our listener\noutershape = TimeOfFlightPlaneWaveToPoint(x, outertime)\nouterparticles = random_particles(Acoustic(2; ρ=0.0, c=0.0), Circle(p_radius);\n        region_shape = outershape,\n        volume_fraction = volfrac,\n        seed=2\n);\n\n# Filter out particles which are less than innertime away\ninnershape = TimeOfFlightPlaneWaveToPoint(x, innertime + 4*p_radius); # the + 4*p_radius is to account for double the particle diameter\nparticles = filter(p -> p⊈innershape, outerparticles);\n\nplot(particles)","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"(Image: )","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"Next we simulate an impulse plane-wave starting at x = -10:","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"ωs = LinRange(0.01, 2.0, 100);\n\nplane_wave = plane_source(Acoustic(1.0, 1.0, 2); direction = [1.0, 0.0], position = x);\nsim = FrequencySimulation(particles, plane_wave);\n\nfreq_response = run(sim, x, ωs);\n\nt_vec = -10.:0.2:81.\ntime_response = frequency_to_time(freq_response; t_vec=t_vec, impulse = GaussianImpulse(1.5; σ = 1.0));\n\nxticks = [0.0, 20.0, 34.0, 40.0, 60.0, 80.0];\nplot(time_response, title=\"Time response from lens\", label=\"\", xticks=xticks)","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"(Image: )","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"The first peak is the incident wave, and the next peak is the wave scattered from the lens which should arrive close to t = 34.","category":"page"},{"location":"manual/time_response/#impulse_details","page":"Time response","title":"Technical details","text":"","category":"section"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"We can calculate the time response u(mathbf xt), from the frequency response hat u(mathbf x omega) by approximating the Fourier transform:","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"u(mathbf xt) = frac12pi int_-infty^infty hat u(mathbf x omega)mathrm e^-mathrm i omega t domega\nquad hat u(mathbf x omega) = int_-infty^infty u(mathbf x t)mathrm e^mathrm i omega t dt","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"where the second equation is the inverse transform. To modify the time response u, we can specify an impulse function hat f(omega) which gives an new time response function phi(mathbf x t):","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"phi(mathbf x t) = frac12pi int_-infty^infty hat f(omega) hat u(mathbf x omega)mathrm e^-mathrm i omega t domega = frac1pimathrmRe int_0^Omega hat f(omega) hat u(mathbf x omega)mathrm e^-mathrm i omega t domega","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"where the second identity results from assuming that phi(mathbf x t) is real, with mathrm Re being the real part. Also note that phi(mathbf xt) = (f * u)(mathbf x t), where * is a convolution in time.","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"To approximate the above integral as finite integral, one option is to assume that hat f(omega) hat u(mathbf x omega) to 0 as omega to 0, which would allow us to truncate the integration domain between omega in -Omega Omega. We also need to discretise the integral. Putting both of these together results in","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"phi(mathbf x t) approx frac1pimathrmRe sum_m=0^M hat f(omega_m) hat u(mathbf x omega_m)mathrm e^-mathrm i omega_m t Delta omega_m","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"where omega_M = Omega and Delta omega_m depends on the scheme used, with the simplest being Delta omega_m = omega_m+1 - omega_m.","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"To learn more see the notes Discrete Fourier Transform or the tests in the folder test of the source code.","category":"page"},{"location":"manual/time_response/","page":"Time response","title":"Time response","text":"tip: Tip\nThe standard way to sample the frequencies is to take omega_m = m Delta omega and Delta omega_m = Delta omega for some constant Delta omega. If we substitute this sampling into the approximation for phi(mathbf x t), shown above, we find that phi(mathbf xt) becomes periodic in time t with period T = 2pi  Delta omega. That is phi(mathbf x t + T) = phi(mathbf x t) for every t. Suppose you were calculating a scattered wave that arrives at time t = T + tau, what would happen? The answer is you would see this scattered wave arrive at time t = tau, assuming tau  T. This wrong arrival time occurs often when waves get trapped due to strong multiple scattering.","category":"page"},{"location":"example/hankel_convergence/README/#Convergence-when-increasing-the-number-of-Hankel-functions","page":"Convergence when increasing the number of Hankel functions","title":"Convergence when increasing the number of Hankel functions","text":"","category":"section"},{"location":"example/hankel_convergence/README/","page":"Convergence when increasing the number of Hankel functions","title":"Convergence when increasing the number of Hankel functions","text":"The code convergence.jl tests how fast does the scattered wave (in frequency) converge when increasing the number of Hankel functions. To describe the scattered wave from each particle we use a series of Hankel functions (of the first kind).","category":"page"},{"location":"example/hankel_convergence/README/","page":"Convergence when increasing the number of Hankel functions","title":"Convergence when increasing the number of Hankel functions","text":"include(\"convergence.jl\")\nsimulations = hankel_order_convergence()\nplot_hankel_order_convergence(simulations)\n","category":"page"},{"location":"example/hankel_convergence/README/","page":"Convergence when increasing the number of Hankel functions","title":"Convergence when increasing the number of Hankel functions","text":"(Image: Plot lens shape and response in time)","category":"page"},{"location":"example/hankel_convergence/README/","page":"Convergence when increasing the number of Hankel functions","title":"Convergence when increasing the number of Hankel functions","text":"In the figures above m is the maximum order of the Hankel functions. The top left figure shows the configuration of particles considered.  ","category":"page"},{"location":"manual/shapes/#Shapes","page":"Shapes","title":"Shapes","text":"","category":"section"},{"location":"manual/shapes/","page":"Shapes","title":"Shapes","text":"DocTestSetup = quote\n    using MultipleScattering\nend","category":"page"},{"location":"manual/shapes/","page":"Shapes","title":"Shapes","text":"Shape is an abstract type which represents the shape of particles, and also the domain to place particles. See Shape for a list of relevant types and functions.","category":"page"},{"location":"manual/shapes/#Existing-shapes","page":"Shapes","title":"Existing shapes","text":"","category":"section"},{"location":"manual/shapes/","page":"Shapes","title":"Shapes","text":"The package provides three basic shapes. You can plot them using:","category":"page"},{"location":"manual/shapes/","page":"Shapes","title":"Shapes","text":"using MultipleScattering;\n\nrectangle = Box([[0.0, -1.0],[1.0, 2.0]]);\ncircle = Sphere([-1.0, 0.0], 1.0);\ntimeofflight = TimeOfFlightPlaneWaveToPoint([1.0, 0.0], 3.0)","category":"page"},{"location":"manual/shapes/","page":"Shapes","title":"Shapes","text":"using Plots;\n\nplot(rectangle, linecolor = :red)\nplot!(circle, linecolor = :green)\nplot!(timeofflight, linecolor = :blue)","category":"page"},{"location":"manual/shapes/","page":"Shapes","title":"Shapes","text":"(Image: Plot the three shapes)","category":"page"},{"location":"manual/shapes/","page":"Shapes","title":"Shapes","text":"The Box and TimeOfFlightPlaneWaveToPoint are usually region where particles are placed. Time of flight is a shape which contains shapes from a half space which take at most t time to reach from the listener. The Circle is also used to define circular particles.","category":"page"},{"location":"example/box_size/README/#Box-size","page":"Box size","title":"Box size","text":"","category":"section"},{"location":"example/box_size/README/","page":"Box size","title":"Box size","text":"If we are only interested in the response at a specific location for a certain time interval, we need only simulate particles which are this distance (or time) away from the listener.","category":"page"},{"location":"example/helmholtz-resonator/resonator/#Helmholtz-resonator","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"","category":"section"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"The code Resonator.jl simulates a 2D Helmlholtz resonator by aligning particles in the shape of a bottle.","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"A Helmholtz resonator is made of a cavity with a small opening mouth. When illuminated with an acoustic waves at its specific resonant frequencies, the scattered field inside the cavity reaches high amplitudes. Those frequencies of course depend on the dimensions of the resonator that we set below.","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"using MultipleScattering\nusing Plots\n\n# The four parameters below are all the required dimensions of the resonator.\ncavity_radius = 1.0;\ncavity_length = 2.5;\nmouth_radius = 0.3;\nmouth_length = 0.5;","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"To simulate the resonator, we align small circular particles to form a cavity. In the code below, the positions of the particles are stored in the vector X.","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"radius = .1; # radius of the particles\nd_particle = 2.001*radius; # distance between centers\n# define the cavity of the resonator\ncavity_up = [\n    [x,cavity_radius+radius]\nfor x = radius:d_particle:cavity_length];\ncavity_down = [\n    [x,-cavity_radius-radius]\nfor x = radius:d_particle:cavity_length]\n\ncavity_right = [\n    [cavity_length+.05*radius,y]\nfor y = (- cavity_radius - radius):d_particle:(cavity_radius+2*radius)]\n\n# define the mouth of the resonator\nmouth_connect_down = [\n    [radius-d_particle,y]\nfor y=(-cavity_radius-radius):d_particle:(-mouth_radius)]\nmouth_connect_up = [\n    [radius-d_particle,y]\nfor y=(mouth_radius+radius):d_particle:(cavity_radius+2*radius)]\n\nmouth_up = [\n    [x,mouth_radius+radius]\nfor x = radius-2*d_particle:-d_particle:-mouth_length-radius]\nmouth_down = [\n    [x,-mouth_radius-radius]\nfor x = radius-2*d_particle:-d_particle:-mouth_length-radius]\n\n# put the different pieces together\nX = [cavity_up; cavity_down; cavity_right; mouth_connect_down; mouth_connect_up; mouth_up; mouth_down];\nX = [x - [cavity_length/2,cavity_radius/2-0.5] for x in X];","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"Now we can define the resonator:","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"particle_medium =  Acoustic(2; ρ = 0., c = 0.);\nResonator = [\n    Particle(particle_medium, Circle(x, radius))\nfor x in X];\nplot(Resonator)\nsavefig(\"Resonator.png\")","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"(Image: Resonator)","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"Next we calculate the scattered field for an incoming plane wave at different frequencies.","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"host_medium = Acoustic(2; ρ=1.0, c=1.0); # medium of the background, 2 is the dimension of the setting.\nsource = plane_source(host_medium; direction = [1.0,0.0])\n\n# region where the result will be plot\nM=N=5.0;\nbottomleft = [-M;-N]; topright = [M;N];\nregion = Box([bottomleft, topright]);\n\nsim = FrequencySimulation(Resonator, source);\nlist_ω = [1.99,3.99,2.74]\nresult = run(sim, region, list_ω, basis_order=5, only_scattered_waves = true; res=200)","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"We plot the results for the different frequencies and observe that omega_0=199 and omega_1=399 correspond to resonant frequencies.","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"for p=1:3 # loop on the different frequencies\n    plot(result, list_ω[p]; seriestype = :heatmap) # clim=(-5.0,5.0)\n    colormap(\"RdBu\")\n    plot!(Resonator,colorbar=true,\n       title=\"Field at ω=\"*string(list_ω[p]),axis=false, xguide =\"\", yguide =\"\")\n    savefig(\"plot_\"*string(p)*\".png\")\nend\n","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"The following plots are obtained:","category":"page"},{"location":"example/helmholtz-resonator/resonator/","page":"Helmholtz resonator","title":"Helmholtz resonator","text":"(Image: p1) (Image: p3) (Image: p2)","category":"page"},{"location":"example/two_particles/README/#Two-particles","page":"Two particles","title":"Two particles","text":"","category":"section"},{"location":"example/two_particles/README/","page":"Two particles","title":"Two particles","text":"Define two particles with the first centred at [1.0,-4.0], with radius 1.0, sound speed 20.0, and density 10.0. The second particle is centered at [3.0,3.0], with radius 3.0, sound speed 1.0, and density 0.1.","category":"page"},{"location":"example/two_particles/README/","page":"Two particles","title":"Two particles","text":"using MultipleScattering\nusing Plots\npyplot()\n\np1 = Particle(Acoustic(2; c = 20.0, ρ = 10.0),Sphere([1.0,-4.0], 1.0))\np2 = Particle(Acoustic(2; c = 1.0, ρ = 0.1),Sphere([3.0,3.0], 3.0))\nparticles = [p1,p2]","category":"page"},{"location":"example/two_particles/README/","page":"Two particles","title":"Two particles","text":"Specify the angular frequency of the incident wave and calculate the response.","category":"page"},{"location":"example/two_particles/README/","page":"Two particles","title":"Two particles","text":"ωs = collect(0.1:0.01:1.0)\nsource = plane_source(Acoustic(1.0, 1.0, 2));\n# Calculate and plot the frequency response at x.\nx = [[-10.0,0.0]];\nsimulation = run(particles, source, x, ωs)\nplot(simulation)","category":"page"},{"location":"example/two_particles/README/","page":"Two particles","title":"Two particles","text":"(Image: Plot against frequency)","category":"page"},{"location":"example/two_particles/README/","page":"Two particles","title":"Two particles","text":"The above used an incident plane with the default position at [0.0, 0.0] and was simultated in the x direction. To change these defaults use:","category":"page"},{"location":"example/two_particles/README/","page":"Two particles","title":"Two particles","text":"x = [[-10.0,-10.0]]\nsource = plane_source(Acoustic(1.0, 1.0, 2); direction = [1.0,1.0], position = [0.0,0.0]);\nsimulation = run(particles, source, x, ωs)","category":"page"},{"location":"example/two_particles/README/","page":"Two particles","title":"Two particles","text":"Then plot the response around the particles and receiver.","category":"page"},{"location":"example/two_particles/README/","page":"Two particles","title":"Two particles","text":"region = Box([[-11.0;-11.0], [6.0;6.0]])\nω = 3.2\nresult = run(particles, source, region, [ω]; res=80)\nplot(result, ω; field_apply=abs, seriestype = :contour)","category":"page"},{"location":"example/two_particles/README/","page":"Two particles","title":"Two particles","text":"(Image: Plot absolute value of wave field)","category":"page"},{"location":"example/two_particles/README/","page":"Two particles","title":"Two particles","text":"The green circle in the plot is the receiver position. Looking at the region between the particles we see the complicated results of multiple scatttering.","category":"page"},{"location":"example/intro/README/#[Go-to-introductory-example](https://github.com/JuliaWaveScattering/MultipleScattering.jl).","page":"Go to introductory example.","title":"Go to introductory example.","text":"","category":"section"},{"location":"maths/README/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"maths/README/","page":"Theory","title":"Theory","text":"Below are papers and notes that explain the theory behind this package.","category":"page"},{"location":"maths/README/#[The-equations-of-Multiple-Scattering](multiplescattering.pdf)","page":"Theory","title":"The equations of Multiple Scattering","text":"","category":"section"},{"location":"maths/README/","page":"Theory","title":"Theory","text":"These short notes introduce the T-matrix, which defines how a particle scatters waves, and shows how it used in multiple scattering from many particles.","category":"page"},{"location":"maths/README/#[Multiple-Scattering-in-the-context-of-acoustics](acoustics.pdf)","page":"Theory","title":"Multiple Scattering in the context of acoustics","text":"","category":"section"},{"location":"maths/README/","page":"Theory","title":"Theory","text":"These notes present the T-matrix construction in the context of acoustics, giving insight into the previous notes. ","category":"page"},{"location":"maths/README/#[Discrete-Fourier-Transform](DiscreteFourier.pdf)","page":"Theory","title":"Discrete Fourier Transform","text":"","category":"section"},{"location":"maths/README/","page":"Theory","title":"Theory","text":"These notes give details on Green’s functions and Fourier transforms. We mostly focus on using discrete impulse functions.","category":"page"},{"location":"maths/README/#[T-matrix-Software](a9-ganesh.pdf)","page":"Theory","title":"T-matrix Software","text":"","category":"section"},{"location":"maths/README/","page":"Theory","title":"Theory","text":"This paper describes a method to calculate the T-matrix for new particles.","category":"page"},{"location":"example/near_surface_backscattering/README/#Near-surface-backscattering","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"","category":"section"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"Near-surface backscattering is a method of accurately calculating the backscattering from an infinite halfspace. For just the code see backscattering.jl First, let us see why it is difficult to approximate the scattering from a halfspace filled with particles. That is, let us find out how many particles are required before the backscattering converges.","category":"page"},{"location":"example/near_surface_backscattering/README/#Generate-a-large-material-filled-with-particles.","page":"Near-surface backscattering","title":"Generate a large material filled with particles.","text":"","category":"section"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"using MultipleScattering\n\nhost_medium = Acoustic(1.0, 1.0, 2)\n\nradius = 0.8\nvolfrac = 0.10\nmax_width = 70.\n\nparticle_medium = Acoustic(0.2, 0.1, 2)\nparticle_shape = Circle(radius)\n\nbottomleft = [0.,-max_width]\ntopright = [max_width,max_width]\n\nshape = Box([bottomleft,topright])\nparticles = random_particles(particle_medium, particle_shape; region_shape = shape, volume_fraction = volfrac)","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"We send an incoming harmonic plane wave and receive the backscattering at x:","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"using Plots\npyplot(linewidth=2)\n\nx = [-10.,0.]\nsource =  plane_source(host_medium; position = x,\n        direction = [1.0,0.],\n        amplitude = 1.0)\n\nplot(particles)\nscatter!([x[1]],[x[2]], lab=\"\")\nannotate!([(x[1], x[2] -max_width/10., \"Receiver\")])\nplot!(shape, linecolor = :red)","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"(Image: The largest quantity of particles used)","category":"page"},{"location":"example/near_surface_backscattering/README/#Calculate-backscattering-for-different-quantity-of-particles","page":"Near-surface backscattering","title":"Calculate backscattering for different quantity of particles","text":"","category":"section"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"We will shave off particles on the right of this group of particles (above), and then calculate the backscattered waves for a range of angular frequencies ωs.","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"ωs = collect(0.01:0.01:1.)\nwidths = 10.:5.:max_width\nnum_particles = zeros(length(widths))\n\nresults = map(eachindex(widths)) do i\n    bottomleft = [0.,-widths[i]]\n    topright = [widths[i],widths[i]]\n    shape = Box([bottomleft, topright])\n\n    ps = filter(p -> p ⊆ shape, particles) # select particles that are inside shape\n    num_particles[i] = Int(length(ps))\n\n    simulation = FrequencySimulation(ps, source)\n    run(simulation, x, ωs)\nend\n\nbackscattered_waves = field.(results)\n\nM = length(backscattered_waves)\nbM = backscattered_waves[M] # backscattering from largest material\ndifferences = [norm(b - bM) for b in backscattered_waves[1:(M-1)]]./norm(bM)\n\nplot_converge = plot(num_particles[1:(M-1)], differences,\n    xlabel = \"number of particles\", yguide =\"error %\",\n    label=\"frequency convergence\"\n)","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"(Image: The convergence of the response in frequency, when increasing the number of particles)","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"The graph shows the rate of convergence, that is, how much the backscattering changes when including more particles (making the material deeper). The graph has not clearly converged, so we can only conclude that more than 400 particles are needed to accurately approximate the backscattering from an infinite halfspace.","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"We can accelerate this convergence by considering backscattering in time.","category":"page"},{"location":"example/near_surface_backscattering/README/#Calculate-backscattering-in-time","page":"Near-surface backscattering","title":"Calculate backscattering in time","text":"","category":"section"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"time_simulations = frequency_to_time.(results)\nreceiver = results[1].x[1]\ntimes = 2*(widths .- receiver[1]) # time it takes for an incident plane wave to reach the furthest particles and then return to the receiver\n\nplot()\nfor i in [1,3,6,9,12,13]\n    plot!(time_simulations[i],label=\"$(num_particles[i]) particles\"\n        , xlims=(0,maximum(times)+10.), ylims=(-0.2,0.1)\n        , xticks = [0.; 30.; times]\n    )\nend\ngui()","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"(Image: The responses in time for different quantity of particles)","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"We see that the responses in time diverge from each other more and more as time goes by. Meaning that if we only calculate the response for a short amount of time 34, then the convergence will be accelerated.","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"time_vec = 0.:pi:34.2\ntime_results = frequency_to_time.(results; t_vec = time_vec, impulse = GaussianImpulse(maximum(ωs)))\n\nbackscattered_waves = field.(time_results)\nbM = backscattered_waves[M] # backscattering from largest material\ndifferences = [norm(b - bM) for b in backscattered_waves[1:(M-1)]]./norm(bM)\nplot(plot_converge)\nplot!(num_particles[1:(M-1)], differences, xlabel = \"number of particles\", yguide =\"error %\", label=\"time convergence\")","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"(Image: Compare converges for responses in time and responses in frequency)","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"The convergence of the time response, for time 0<t<34, is much faster. In fact, less than 100 particles are needed to accurately approximate the backscattering from an infinite halfspace. The reason we don't show these as log plots is because there is a small constant error (about 0.01%) due to the discrete Fourier transform. This error is caused by the Gibbs phenomena and by assuming the backscattering is periodic (when it is not). Both these errors are well understood and can be controlled.","category":"page"},{"location":"example/near_surface_backscattering/README/#Calculate-backscattering-only-from-near-surface-particles","page":"Near-surface backscattering","title":"Calculate backscattering only from near-surface particles","text":"","category":"section"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"This last step is about efficiency. We want to only include particle which contribute to the backscattering for short time intervals. To do this we created a region called TimeOfFlightPlaneWaveToPoint(listener,time), where every particle in this shape takes less than time for their first scattered wave (due to an incident plane wave) to return to the listener.  More precisely, if listener = (lx,ly), then every point (x,y) inside this shape satisfies: x-lx+((x-lx)^2+(y-ly)^2)^(1/2)<time and x>0.","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"For example, look at the largest quantity of particle we used","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"listener_position = [-10.,0.]\nshape = TimeOfFlightPlaneWaveToPoint(listener_position,80.0)\nscatter([listener_position[1]],[listener_position[2]]);\nannotate!([(listener_position[1], listener_position[2] -max_width/10., \"Receiver\")])\nplot!.(particles);\nplot!(shape)","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"(Image: Shows the particles in the shape TimeOfFlightPlaneWaveToPoint)","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"For time 0<t<80 the backscattering from these particles is the same as an infinite halfspace filled with particles. To achieve this result we need only the particles inside the shape TimeOfFlightPlaneWaveToPoint (region with the red outline). The particles outside this shape were unnecessary. To see this inaction:","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"times = 40.:15.:80.\nnear_surface_simulations = map(times) do t\n    shape = TimeOfFlightPlaneWaveToPoint(receiver,t) # choose a material with particles only in the near surface region\n    ps = filter(p -> p ⊆ shape, particles) # select particles that are inside shape\n    run(FrequencySimulation(ps, source), x, ωs) # calculate backscattering\nend\n\ntime_near_simulations = frequency_to_time.(near_surface_simulations; impulse = GaussianImpulse(maximum(ωs)))\n\nplot()\nfor i in 1:length(times)\n    plot!(time_near_simulations[i],label=\"time of flight $(times[i])\"\n        , xlims=(0,maximum(times)+10.), ylims=(-0.6,0.3)\n        , xticks = [0.; times], title=\"\"\n    )\nend\ngui()","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"(Image: Response from particles in the shapes TimeOfFlightPlaneWaveToPoint)","category":"page"},{"location":"example/near_surface_backscattering/README/","page":"Near-surface backscattering","title":"Near-surface backscattering","text":"Note the incident pulse has a thickness of about 10 in time, which is why the time of flight 40 diverges from the other curves slightly before time 40, and likewise for the other curves.","category":"page"},{"location":"example/particles_in_circle/README/#Random-particles-in-a-circle","page":"Random particles in a circle","title":"Random particles in a circle","text":"","category":"section"},{"location":"example/particles_in_circle/README/","page":"Random particles in a circle","title":"Random particles in a circle","text":"The code particlesincircle.jl compares the scattered wave from one big circle, with the scattered wave from a circle filled with small particles.","category":"page"},{"location":"example/particles_in_circle/README/","page":"Random particles in a circle","title":"Random particles in a circle","text":"using MultipleScattering\n\n#You can also pick your own shape, an generate random particles inside it\n#with a certain radius ands volume fraction\nradius = 0.3\nvolfrac = 0.45\ncentre = [0.,0.]\nbig_radius = 3.0\n\nparticle_medium = Acoustic(2; ρ=0.0, c=0.0) # 2D particle with density ρ = 0.0 and soundspeed c = 0.0\nparticle_shape = Circle(radius)\n\ncircle = Sphere(centre, big_radius)\n\nparticles = random_particles(particle_medium, particle_shape; region_shape = circle, volume_fraction = volfrac, seed=1)\n\nx = [-10.,0.] # position to receive the reflected wave\nhost_medium = Acoustic(2; ρ=1.0, c=1.0)\nsource =  plane_source(host_medium; position = x, direction = [1.0,0.])\nsimulation = FrequencySimulation(particles, source)","category":"page"},{"location":"example/particles_in_circle/README/","page":"Random particles in a circle","title":"Random particles in a circle","text":"The particles chosen are impenetrable, i.e. the wave is 100\\% reflected. So this circle filled with scatterers should act like one big particle.","category":"page"},{"location":"example/particles_in_circle/README/","page":"Random particles in a circle","title":"Random particles in a circle","text":"big_particle = Particle(particle_medium, circle)\nbig_particle_simulation = FrequencySimulation([big_particle], source)\n\n#define a bounding box for plot\n    bottomleft = [-10, -2*big_radius]\n    topright = [big_radius, 2*big_radius]\n    box = Box([bottomleft, topright])\n\nusing Plots\nheight = 300\n#gr(size=(1.4*height,height))\npyplot(leg=false, size=(1.4*height,height))\n\nω = 0.5\n#plot(big_particle_simulation, ω; res=15, bounds = box);\n#plot!(big_particle)\n\n#savefig(\"plot_field_big.png\")\n\n#plot(simulation, ω; res=15, bounds = box);\n#plot!(particles, linecolor = :green)\n\n#savefig(\"plot_field.png\")","category":"page"},{"location":"example/particles_in_circle/README/","page":"Random particles in a circle","title":"Random particles in a circle","text":"Resulting in the figures:","category":"page"},{"location":"example/particles_in_circle/README/","page":"Random particles in a circle","title":"Random particles in a circle","text":"(Image: The field with big particle) (Image: The field with particles)","category":"page"},{"location":"example/particles_in_circle/README/","page":"Random particles in a circle","title":"Random particles in a circle","text":"If we compare the response measured at the listener [-10., 0.], they should be very similar:","category":"page"},{"location":"example/particles_in_circle/README/","page":"Random particles in a circle","title":"Random particles in a circle","text":"#define angular frequency range\nωs = collect(LinRange(0.1,1.0,10))\nresult = run(simulation, x, ωs)\nbig_result = run(big_particle_simulation, x, ωs)\n\n#plot(result, lab = \"scattering from particles\")\n#plot!(big_result,\n#    lab = \"scattering from big particle\",\n#    title=\"Compare scattered wave from one big particle, \\n and a circle filled with small particles\"\n# )","category":"page"},{"location":"example/particles_in_circle/README/","page":"Random particles in a circle","title":"Random particles in a circle","text":"(Image: The response comparison)","category":"page"},{"location":"manual/particles/#Particles","page":"Particles","title":"Particles","text":"","category":"section"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"DocTestSetup = quote\n    using MultipleScattering\nend","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"Particle is a struct which define a scatterer, obstacle, or simply particle, which can scatter waves. See Particle for a list of relevant types and functions.","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"A Particle have two fields: medium and shape. The medium defines what kind of waves can propagate inside Particle, and what type of RegularSource can be used to scatter waves from Particle. One example medium is Acoustic. The shape completely defines the geometry and position of the particle, see Shapes for details.","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"For an example we can define a circular particle with acoustics medium:","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"using MultipleScattering;\n\nmymedium = Acoustic(2; ρ = 10.0, c = 2.0); # 2D acoustics with density ρ = 10.0 and soundspeed c = 2.0\nmyshape = Sphere([-2.0, 2.0], 2.0);\np1 = Particle(mymedium, myshape);","category":"page"},{"location":"manual/particles/#Placing-particles-in-a-region","page":"Particles","title":"Placing particles in a region","text":"","category":"section"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"Suppose we want to place many circular particles in a region. The region has to be a pre-defined Shape, for example a Circle:","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"# Define the region\ncentre = [0.0, 0.0];\nbig_radius = 3.0;\ncircle = Sphere(centre, big_radius);\n\n# Define the particle geometry and medium\np_radius = 0.3;\nmyshape = Circle(p_radius); # we do not specify centre as it is not used by random_particles\nmymedium = Acoustic(2; ρ = 10.0, c = 2.0);\n\n# Generate particles inside circle\nvolfrac = 0.2;\nparticles = random_particles(mymedium, myshape;\n    region_shape = circle,\n    volume_fraction = volfrac,\n    seed = 1\n);\n\nusing Plots;\n\nplot(particles)\nplot!(circle, linecolor = :red)","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"(Image: Particles in circle)","category":"page"},{"location":"manual/particles/#Placing-polydisperse-particles-in-a-region","page":"Particles","title":"Placing polydisperse particles in a region","text":"","category":"section"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"Similar to the above, we can place particles with a range of shapes.","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"Suppose we want to add to the above example a range of smaller particles:","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"\n# Define a range of particles sizes\nrs = [0.05, 0.15, 0.15, 0.2]; # by repeating the radius 0.15 twice, there will be twice as many particles with this radius.\nmyshapes = Circle.(rs);\nmymedium = Acoustic(2; ρ = 0.2, c = 0.2);\n\n# Generate particles inside circle\nvolfrac = 0.15\npolydisperse_particles = random_particles(mymedium, myshapes;\n    current_particles = particles,\n    region_shape = circle,\n    volume_fraction = volfrac,\n    seed = 1\n);\n\nplot(polydisperse_particles, linecolor = :green)\nplot!(particles, linewidth = 2.0)\nplot!(circle, linecolor = :red)","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"(Image: Particles in circle)","category":"page"},{"location":"manual/particles/#Removing-particles","page":"Particles","title":"Removing particles","text":"","category":"section"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"Say we want to place a point-source within region filled with particles. To avoid placing the source inside any particle, we can remove a small region of particles:","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"small_circle = Circle(1.2);\n\nfilter!(p -> !(p ⊆ small_circle), polydisperse_particles)\n\nplot(polydisperse_particles, linecolor = :green)\nplot!(circle, linecolor = :red)","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"(Image: Particles in circle)","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"Next we place a point source in the centre and plot the result, while excluding a small region Circle(0.1) to avoid the singularity caused by a point source:","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"ω = 0.4;\npoint_wave = point_source(Acoustic(2; ρ = 1.0, c = 1.0), [0.0, 0.0]);\nsim = FrequencySimulation(polydisperse_particles, point_wave);\nplot(sim, ω;\n        resolution = 20,\n        exclude_region = Circle(0.1),\n        drawparticles = true\n)","category":"page"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"(Image: Particles in circle)","category":"page"},{"location":"manual/particles/#Particle-internals","page":"Particles","title":"Particle internals","text":"","category":"section"},{"location":"manual/particles/","page":"Particles","title":"Particles","text":"To define the scattering from a particle we use the T-matrix method. This package only exports T-matrix for circular Particle  and circular CapsuleParticle. To understand how to define new T-matrix read Notes on the T-matrix and see the source code of t_matrix.","category":"page"},{"location":"example/random_particles/README/#Simple-random-particles-example","page":"Simple random particles example","title":"Simple random particles example","text":"","category":"section"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"\n## Define particle properties\nDefine the volume fraction of particles, the region to place the particles, and their radius","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"julia using MultipleScattering num_particles = 4 radius = 1.0","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"particlemedium = Acoustic(2; ρ=0.2, c=0.1) # 2D particle with density ρ = 0.2 and soundspeed c = 0.1 particleshape = Circle(radius)","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"maxwidth = 20*radius bottomleft = [0.,-maxwidth] topright = [maxwidth,maxwidth] region_shape = Box([bottomleft,topright])","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"particles = randomparticles(particlemedium, particleshape; regionshape = regionshape, numparticles = num_particles)","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"\nNow choose the receiver position `x`, the host medium, set plane wave as a source wave, and choose the angular frequency range `ωs`","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"julia x = [-10.,0.] hostmedium = Acoustic(2; ρ=1.0, c=1.0) source =  planesource(host_medium; position = x, direction = [1.0,0.])","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"ωs = LinRange(0.01,1.0,100)","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"simulation = FrequencySimulation(particles, source) result = run(simulation, x, ωs)","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"\nWe use the `Plots` package to plot both the response at the listener position x\n","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"julia     using Plots; #pyplot(linewidth = 2.0)     plot(result, fieldapply=real) # plot result     plot!(result, fieldapply=imag)     #savefig(\"plot_result.png\")","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"![Plot of response against wavenumber](plot_result.png)\n\nAnd plot the whole field inside the region_shape `bounds` for a specific wavenumber (`ω=0.8`)","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"julia     bottomleft = [-15.,-maxwidth]     topright = [maxwidth,max_width]     bounds = Box([bottomleft,topright])","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"#plot(simulation,0.8; res=80, bounds=bounds)\n#plot!(region_shape, linecolor=:red)\n#plot!(simulation)\n#scatter!([x[1]],[x[2]], lab=\"receiver\")\n\n#savefig(\"plot_field.png\")","category":"page"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"``` (Image: Plot real part of acoustic field)","category":"page"},{"location":"example/random_particles/README/#Things-to-try","page":"Simple random particles example","title":"Things to try","text":"","category":"section"},{"location":"example/random_particles/README/","page":"Simple random particles example","title":"Simple random particles example","text":"Try changing the volume fraction, particle radius and ω values we evaluate","category":"page"},{"location":"library/base/#Base","page":"Base","title":"Base","text":"","category":"section"},{"location":"library/base/","page":"Base","title":"Base","text":"CurrentModule = MultipleScattering","category":"page"},{"location":"library/base/","page":"Base","title":"Base","text":"Pages = [\"base.md\"]","category":"page"},{"location":"library/base/#base_physical_property","page":"Base","title":"Physical mediums","text":"","category":"section"},{"location":"library/base/","page":"Base","title":"Base","text":"The types and functions shared between all different types of physical mediums.","category":"page"},{"location":"library/base/","page":"Base","title":"Base","text":"Modules = [MultipleScattering]\nOrder   = [:type, :function]\nPages   = [\"src/physics/physical_medium.jl\", \"src/physics/special_functions.jl\"]","category":"page"},{"location":"library/base/#MultipleScattering.PhysicalMedium","page":"Base","title":"MultipleScattering.PhysicalMedium","text":"PhysicalMedium{Dim,FieldDim}\n\nAn abstract type used to represent the physical medium, the dimension of the field, and the number of spatial dimensions. We expect every sub-type of PhysicalMedium{Dim,1} to have a field c which is the complex wave speed. \n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.ScalarMedium","page":"Base","title":"MultipleScattering.ScalarMedium","text":"ScalarMedium{Dim}\n\nAn type used to represent a scalar wave which satisfies a Helmoholtz equations. Dim represents the number of spatial dimensions.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.boundary_data","page":"Base","title":"MultipleScattering.boundary_data","text":"A tuples of vectors of the field close to the boundary of the shape. The field is calculated from sim::FrequencySimulation, but the PhysicalMedium inside and outside of the shape are assumed to be given by insidemedium and outsidemedium.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.estimate_regular_basisorder-Tuple{PhysicalMedium,Number,Number}","page":"Base","title":"MultipleScattering.estimate_regular_basisorder","text":"estimate_regular_basis_order(medium::PhysicalMedium, ω::Number, radius::Number; tol = 1e-6)\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.field_dimension-Union{Tuple{PhysicalMedium{Dim,FieldDim}}, Tuple{FieldDim}, Tuple{Dim}} where FieldDim where Dim","page":"Base","title":"MultipleScattering.field_dimension","text":"Extract the dimension of the field of this physical property\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.field_dimension-Union{Tuple{Type{P}}, Tuple{P}, Tuple{FieldDim}, Tuple{Dim}} where P<:PhysicalMedium{Dim,FieldDim} where FieldDim where Dim","page":"Base","title":"MultipleScattering.field_dimension","text":"Extract the dimension of the field of this type of physical property\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.internal_field","page":"Base","title":"MultipleScattering.internal_field","text":"the field inside an AbstractParticle a some given point x.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.outgoing_basis_function","page":"Base","title":"MultipleScattering.outgoing_basis_function","text":"Basis of outgoing wave. A series expansion in this basis should converge to any scattered field outside of a ball which contains the scatterer.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.regular_basis_function","page":"Base","title":"MultipleScattering.regular_basis_function","text":"A basis for regular functions, that is, smooth functions. A series expansion in this basis should converge to any regular function within a ball.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.spatial_dimension-Union{Tuple{PhysicalMedium{Dim,FieldDim}}, Tuple{FieldDim}, Tuple{Dim}} where FieldDim where Dim","page":"Base","title":"MultipleScattering.spatial_dimension","text":"Extract the dimension of the space that this physical property lives in\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.spatial_dimension-Union{Tuple{Type{P}}, Tuple{P}, Tuple{FieldDim}, Tuple{Dim}} where P<:PhysicalMedium{Dim,FieldDim} where FieldDim where Dim","page":"Base","title":"MultipleScattering.spatial_dimension","text":"Extract the dimension of the space that this type of physical property lives in\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.diffbessel-Tuple{Function,Number,Any,Int64}","page":"Base","title":"MultipleScattering.diffbessel","text":"diffbessel(f::Function,m,x,n::Int)\n\nDifferentiates 'n' times any bessel function 'f' of order 'm' and at the argument 'x'.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.diffbesselj-Union{Tuple{T}, Tuple{Number,T,Int64}} where T<:Number","page":"Base","title":"MultipleScattering.diffbesselj","text":"m-th Derivative of Hankel function of the first kind\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.diffbesselj-Union{Tuple{T}, Tuple{Number,T}} where T<:Number","page":"Base","title":"MultipleScattering.diffbesselj","text":"Derivative of Bessel function of first kind\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.diffhankelh1-Tuple{Any,Any}","page":"Base","title":"MultipleScattering.diffhankelh1","text":"Derivative of Hankel function of the first kind\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.diffhankelh1-Union{Tuple{T}, Tuple{Number,T,Int64}} where T<:Number","page":"Base","title":"MultipleScattering.diffhankelh1","text":"diffhankelh1(m,x,n::Int)\n\nDifferentiates 'n' times the hankelh1 function of order 'm' and at the argument 'x'.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.diffsbessel-Tuple{Function,Number,Number}","page":"Base","title":"MultipleScattering.diffsbessel","text":"diffsbessel(f::Function,m,x)\n\nDifferentiates the spherical bessel function 'f' (for any spherical bessel). The order is 'm' and the argument is 'x'. Note 'x' can be a complex number.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.gaunt_coefficient-Tuple{Type{var\"#s45\"} where var\"#s45\"<:AbstractFloat,Int64,Int64,Int64,Int64,Int64,Int64}","page":"Base","title":"MultipleScattering.gaunt_coefficient","text":"gaunt_coefficient(l1,m1,l2,m2,l3,m3)\n\nA version of the Gaunt coefficients which are used to write the product of two spherical harmonics. If Y_{l,m} is a complex spherical harmonic, with the typical phase conventions from quantum mechanics, then:\n\ngaunt_coefficient(l1,m1,l2,m2,l3,m3) = 4*π*im^{l2+l3-l1} Integral[Y_{l1,m1}*conj(Y_{l2,m2})*conj(Y_{l3,m3})]\n\nwhere the integral is over the solid angle.\n\nThe most standard gaunt coefficients G(l1,m1;l2,m2;l3) are related through the identity:\n\n4pi * G(l1,m1;l2,m2;l3) = im^(l1-l2-l3) * (-1)^m2 * gaunt_coefficient(l1,m1,l2,-m2,l3,m1+m2)\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.shankelh1-Union{Tuple{T}, Tuple{Number,T}} where T","page":"Base","title":"MultipleScattering.shankelh1","text":"shankelh1(m,x)\n\nReturns the spherical hankel function of the first kind. The order is 'm' and the argument is 'x'. Note 'x' can be a complex number.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.spherical_harmonics-Union{Tuple{T}, Tuple{Int64,Complex{T},Union{Complex{T}, T}}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.spherical_harmonics","text":"spherical_harmonics(l_max::Int, θ::T, φ::T)\n\nreturns a vector of all spherical harmonics with degree l <= l_max. The degree and order (indices) of the elements of the vector are given by spherical_harmonics_indices(l_max::Int).\n\nThe associated legendre polynomials are taken from the package GSL.jl.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.spherical_harmonics-Union{Tuple{T}, Tuple{Int64,T,T}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.spherical_harmonics","text":"spherical_harmonics_dθ(l_max::Int, θ::T, φ::T)\n\nReturns a vector of all the spherial harmonics Y_(lm)(thetaphi) for all the degrees l and orders m.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.spherical_harmonics_dθ-Union{Tuple{T}, Tuple{Int64,T,T}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.spherical_harmonics_dθ","text":"spherical_harmonics_dθ(l_max::Int, θ::T, φ::T)\n\nReturns a vector of all partial Y_(lm)(thetaphi)  partial theta for all the degrees l and orders m.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#base_shapes","page":"Base","title":"Shapes and domains","text":"","category":"section"},{"location":"library/base/","page":"Base","title":"Base","text":"Shapes are used to define the shape of particles, and to define containers (or configurations) where all particles are placed. It is also used in plotting.","category":"page"},{"location":"library/base/","page":"Base","title":"Base","text":"Modules = [MultipleScattering]\nOrder   = [:type, :function]\nPages   = [\"src/shapes/shapes.jl\", \"src/shapes/sphere.jl\", \"src/shapes/halfspace.jl\", \"src/shapes/plate.jl\", \"src/shapes/box.jl\", \"src/shapes/empty_shape.jl\", \"src/shapes/time_of_flight.jl\"]","category":"page"},{"location":"library/base/#MultipleScattering.Shape","page":"Base","title":"MultipleScattering.Shape","text":"Abstract idea which defines the external boundary of object.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.Shape-Tuple{Shape}","page":"Base","title":"MultipleScattering.Shape","text":"Shape(shape::Shape; addtodimensions = 0.0, vector_translation = zeros(...), kws...)\n\nAlter the shape depending on the keywords.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#Base.in-Tuple{AbstractArray{T,1} where T,Shape}","page":"Base","title":"Base.in","text":"in(vector, shape)::Bool\n\nReturns true if vector is in interior of shape, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#Base.issubset-Tuple{Shape,Shape}","page":"Base","title":"Base.issubset","text":"issubset(shape1, shape2)::Bool\n\nReturns true if shape1 is entirely contained within shape2, false otherwise (also works with particles).\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.:≅-Tuple{Shape,Shape}","page":"Base","title":"MultipleScattering.:≅","text":"iscongruent(p1::Shape, p2::Shape)::Bool\n≅(p1::Shape, p2::Shape)::Bool\n\nTrue if shapes are the same but in different positions (origins), standard mathematical definition.\n\n\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.boundary_functions","page":"Base","title":"MultipleScattering.boundary_functions","text":"volume(shape::Shape)::NTuple{Function,Dim)\n\nReturns Tuple of Dim Functions which define outer boundary of shape when given boundary coordinate t∈[0,1]\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.boundary_points","page":"Base","title":"MultipleScattering.boundary_points","text":"Returns a set of points on the boundary of a 3D shape.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.boundary_points-2","page":"Base","title":"MultipleScattering.boundary_points","text":"Returns a set of points on the boundary of a 2D shape.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.bounding_box-Tuple{Shape,Shape}","page":"Base","title":"MultipleScattering.bounding_box","text":"Returns box which completely encloses the shapes\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.check_boundary_coord_range-Tuple{Any}","page":"Base","title":"MultipleScattering.check_boundary_coord_range","text":"Generic helper function which tests if boundary coordinate is between 0 and 1\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.congruent","page":"Base","title":"MultipleScattering.congruent","text":"congruent(s::Shape, x)::Shape\n\nCreate shape congruent to s but with origin at x\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.iscongruent-Tuple{Shape,Shape}","page":"Base","title":"MultipleScattering.iscongruent","text":"iscongruent(p1::Shape, p2::Shape)::Bool\n≅(p1::Shape, p2::Shape)::Bool\n\nTrue if shapes are the same but in different positions (origins), standard mathematical definition.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.name","page":"Base","title":"MultipleScattering.name","text":"name(shape::Shape)::String\n\nName of a shape\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.number_type-Tuple{Shape}","page":"Base","title":"MultipleScattering.number_type","text":"number_type(shape::Shape)::DataType\n\nNumber type which is used to describe shape, defaults to the eltype of the origin vector.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.origin-Tuple{Shape}","page":"Base","title":"MultipleScattering.origin","text":"origin(shape::Shape)::SVector\n\nOrigin of shape, typically the center\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.outer_radius","page":"Base","title":"MultipleScattering.outer_radius","text":"outer_radius(shape::Shape)\n\nThe radius of a circle which completely contains the shape\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.points_in_shape-Tuple{Shape{2}}","page":"Base","title":"MultipleScattering.points_in_shape","text":"points_in_shape(Shape; resolution = 20, xres = resolution, yres = resolution,\n         exclude_region = EmptyShape(region), kws...)\n\nreturns (x_vec, region_inds) where x_vec is a vector of points that cover a box which bounds Shape, and region_inds is an array of linear indices such that x_vec[region_inds] are points contained Shape. For 3D we use zres instead of yres.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.volume","page":"Base","title":"MultipleScattering.volume","text":"volume(shape::Shape)\n\nVolume of a shape\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.Halfspace","page":"Base","title":"MultipleScattering.Halfspace","text":"Halfspace(normal::AbstractVector{T} [, origin::AbstractVector{T}=zeros()])\n\nA halfspace defined by all the points mathbf x that satify (mathbf x - mathbf o) cdot mathbf n  0 where mathbf n is the unit normal and mathbf o is the origin.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.Plate","page":"Base","title":"MultipleScattering.Plate","text":"Plate(normal::AbstractVector{T}, width::T, [, origin::AbstractVector{T}=zeros()])\n\nA plate defined by all the points mathbf x that satify (mathbf x - mathbf o) cdot mathbf n  w 2 where mathbf n is the unit normal, mathbf o is the origin, and w is the width.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.Box","page":"Base","title":"MultipleScattering.Box","text":"Box([origin::AbstractVector{T}=zeros(),] dimensions::AbstractVector{T})\n\nA Box for 2D and 3D with axis aligned sides, defined by dimensions and origin (at the center).\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.Box-Tuple{Array{v,1} where v<:(AbstractArray{T,1} where T)}","page":"Base","title":"MultipleScattering.Box","text":"Box(points::Vector{v} where v <: AbstractVector)\n\nA Box for any dimension with axis aligned sides, that is a minimal cover for the points.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.bottomleft-Union{Tuple{Box{T,2}}, Tuple{T}} where T","page":"Base","title":"MultipleScattering.bottomleft","text":"Return SVector with the coordinates of the bottom left of a rectangle\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.corners-Union{Tuple{Box{T,Dim}}, Tuple{Dim}, Tuple{T}} where Dim where T","page":"Base","title":"MultipleScattering.corners","text":"Returns a vector of SVector with the coordinates of the corners of the box\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.topright-Union{Tuple{Box{T,2}}, Tuple{T}} where T","page":"Base","title":"MultipleScattering.topright","text":"Return SVector with the coordinates of the top right of a rectangle\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.EmptyShape","page":"Base","title":"MultipleScattering.EmptyShape","text":"EmptyShape{Dim}\n\nAn empty shape with no points.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.TimeOfFlightPlaneWaveToPoint","page":"Base","title":"MultipleScattering.TimeOfFlightPlaneWaveToPoint","text":"A shape which contains all particles,x  x_0, necessary to simulate a plane-wave scattering from an infinite medium, for a reciever at the focal point, for time t  D  c, where c is the sound speed of the background medium, and D is some chosen focal distance. The plane-wave travels towards the positive direction of the x axis.\n\nMore precisely, if the focal point is at (x_fy_f) then the interior of the shape is defined as (y - y_f)^2  (D + x_0)^2 - x_f^2 - 2(D + x_0 - x_f)x  and x  min(x_0 x_f) where D is the focal distance.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#base_particle","page":"Base","title":"Particle","text":"","category":"section"},{"location":"library/base/","page":"Base","title":"Base","text":"Particle types and functions.","category":"page"},{"location":"library/base/","page":"Base","title":"Base","text":"AbstractParticle\nParticle\nCapsuleParticle\niscongruent(::AbstractParticle,::AbstractParticle)","category":"page"},{"location":"library/base/#MultipleScattering.AbstractParticle","page":"Base","title":"MultipleScattering.AbstractParticle","text":"Object we can scatter waves off\n\nSubtypes will contain information about shape and material properties. Most crucially, they will implement the t_matrix function\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.Particle","page":"Base","title":"MultipleScattering.Particle","text":"Particle(medium::PhysicalMedium, shape::Shape)\n\nCreate particle with inner medium and shape (dimensions must agree).\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.CapsuleParticle","page":"Base","title":"MultipleScattering.CapsuleParticle","text":"CapsuleParticle(outer::Particle, inner::Particle)\n\nA particle within another particle, both with the same shape type and origin.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.iscongruent-Tuple{AbstractParticle,AbstractParticle}","page":"Base","title":"MultipleScattering.iscongruent","text":"iscongruent(p1::AbstractParticle, p2::AbstractParticle)::Bool\n≅(p1::AbstractParticle, p2::AbstractParticle)::Bool\n\nReturns true if medium and shape of particles are the same, ignoring origin, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#source_base","page":"Base","title":"RegularSource","text":"","category":"section"},{"location":"library/base/","page":"Base","title":"Base","text":"RegularSource types and functions for all physical mediums.","category":"page"},{"location":"library/base/","page":"Base","title":"Base","text":"Modules = [MultipleScattering]\nOrder   = [:type, :function]\nPages   = [\"src/source.jl\"]","category":"page"},{"location":"library/base/#MultipleScattering.AbstractSource","page":"Base","title":"MultipleScattering.AbstractSource","text":"Represent any source (incident) wave\n\nSubtypes may have a symmetry (such as PlaneSource) and will contain information about physical medium.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.PlaneSource","page":"Base","title":"MultipleScattering.PlaneSource","text":"PlaneSource(medium::P, amplitude::SVector, direction::SVector)\n\nIs a struct type which describes a plane-wave source that drives/forces the whole system. It has three fields: a physical medium, an amplitude of the source, and the direction the propagate in direction.\n\nFor any given angular frequency ω, the PlaneSource has the value e^i ωc mathbf v cdot mathbf x  at the point mathbf x, where c is the medium wavespeed and mathbf v is the direction.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.RegularSource","page":"Base","title":"MultipleScattering.RegularSource","text":"RegularSource(medium::P, field::Function, coef::Function)\n\nIs a struct type which describes the source field that drives/forces the whole system. It is also known as an incident wave. It has three fields RegularSource.medium, RegularSource.field, and RegularSource.coef.\n\nThe source field at the position 'x' and angular frequency 'ω' is given by\n\nx = [1.0,0.0]\nω = 1.0\nRegularSource.field(x,ω)\n\nThe field RegularSource.coef regularbasisfunction(medium::Acoustic{T,2}, ω::T)\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.regular_spherical_coefficients-Tuple{RegularSource}","page":"Base","title":"MultipleScattering.regular_spherical_coefficients","text":"regular_spherical_coefficients(source::RegularSource)\n\nreturn a function which can calculate the coefficients of a regular spherical wave basis.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.regular_spherical_source-Union{Tuple{CT}, Tuple{Dim}, Tuple{T}, Tuple{PhysicalMedium{Dim,FieldDim} where FieldDim,AbstractArray{CT,1}}} where CT<:Union{Complex{T}, T} where Dim where T","page":"Base","title":"MultipleScattering.regular_spherical_source","text":"regular_spherical_source(PhysicalMedium,regular_coefficients; amplitude = one(T), position = zeros(T,Dim))\n\nc_n =regular_coefficients[n], x_o=position, and let v_n(kx) represent the regular spherical basis with wavenumber k at position x. The above returns a source where source.field(x,ω) =sum_n c_n v_n(kx -k x_0)\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.self_test-Union{Tuple{RegularSource{P,S} where S<:AbstractSymmetry}, Tuple{P}} where P","page":"Base","title":"MultipleScattering.self_test","text":"Check that the source functions return the correct types\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.source_expand-Union{Tuple{T}, Tuple{AbstractSource,AbstractArray{T,1}}} where T","page":"Base","title":"MultipleScattering.source_expand","text":"source_expand(RegularSource, centre; basis_order = 4)\n\nReturns a function of (x,ω) which approximates the value of the source at (x,ω). That is, the source is written in terms of a regular basis expansion centred at centre.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#impulse_base","page":"Base","title":"Impulse","text":"","category":"section"},{"location":"library/base/","page":"Base","title":"Base","text":"For convert to the time domain.","category":"page"},{"location":"library/base/","page":"Base","title":"Base","text":"Modules = [MultipleScattering]\nOrder   = [:type, :function]\nPages   = [\"src/impulse.jl\", \"src/time_simulation.jl\"]","category":"page"},{"location":"library/base/#MultipleScattering.ContinuousImpulse","page":"Base","title":"MultipleScattering.ContinuousImpulse","text":"See also: DiscreteImpulse, frequency_to_time\n\nContinuousImpulse{T<:AbstractFloat}\n\nA struct used to represent an analytic impulse function. Has two fields: in_time a function of time t, and in_freq a function of the angular frequency ω. in_freq should be the Fourier transform of in_time, though this is not enforced.\n\nWe use the Fourier transform convention: F(ω) =  ∫ f(t)exp(imωt) dt, f(t) = (2π)^(-1) * ∫ F(ω)exp(-imωt) dω.\n\nAn impluse f(t) is convoluted in time with the field u(t), however we avoid the convolution by working with the fourier transform F(ω) of the impulse f(t), which results in\n\nfrequency to time: (2π)^(-1) * ∫ F(ω)U(ω)exp(-imωt) dω\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.DiscreteImpulse","page":"Base","title":"MultipleScattering.DiscreteImpulse","text":"See also: ContinuousImpulse, frequency_to_time, DiscreteGaussianImpulse\n\nDiscreteImpulse{T<:AbstractFloat}\n\nA struct used to represent a numerical impulse. Only the fields: in_freq which is the frequency response vector, and the frequency vector ω are required to use this struct to use in the function frequency_to_time.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.DiscreteGaussianImpulse-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}, Tuple{AbstractArray{T,N} where N,AbstractArray{T,N} where N}} where T","page":"Base","title":"MultipleScattering.DiscreteGaussianImpulse","text":"See also: ContinuousImpulse, TimeDiracImpulse\n\nDiscreteGaussianImpulse(t_vec[, ω_vec])\n\nReturns a discretised gaussian impulse.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.FreqDiracImpulse-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.FreqDiracImpulse","text":"Dirac Delta function of unit area in the frequency domain centred at ω=ω0.\n\nWarning: in frequency space this is a singuarity and so may lead to unexpected behaviour.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.GaussianImpulse-Tuple{T} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.GaussianImpulse","text":"See also: ContinuousImpulse, TimeDiracImpulse\n\nGaussianImpulse(maxω[; σ = 3.0/maxω^2])\n\nReturns a gaussian impulse function, which in the frequency domain is exp(-σ*ω^2)*(2sqrt(σ*pi)).\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.TimeDiracImpulse-Tuple{T} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.TimeDiracImpulse","text":"TimeDiracImpulse(t0::T)\n\nDirac Delta function of unit area in the time domain centred at t=t0.\n\nWarning: in the time domain this is a singuarity and so may lead to unexpected behaviour.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.continuous_to_discrete_impulse-Union{Tuple{T}, Tuple{ContinuousImpulse{T},AbstractArray{T,N} where N}, Tuple{ContinuousImpulse{T},AbstractArray{T,N} where N,AbstractArray{T,N} where N}} where T","page":"Base","title":"MultipleScattering.continuous_to_discrete_impulse","text":"continuous_to_discrete_impulse(impulse::ContinuousImpulse, t_vec, ω_vec = t_to_ω(t_vec); t_shift = 0.0, ω_shift = 0.0)\n\nReturns a DiscreteImpulse by sampling impulse. The signal can be shifted in time and frequency by choosing t_shit and ω_shift.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.self_test-Union{Tuple{ContinuousImpulse{T}}, Tuple{T}} where T","page":"Base","title":"MultipleScattering.self_test","text":"Check that the continuous impulse functions return the correct types\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.self_test-Union{Tuple{DiscreteImpulse{T}}, Tuple{T}} where T","page":"Base","title":"MultipleScattering.self_test","text":"Check that the discrete impulse vectors are the right sizes\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.firstnonzero-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.firstnonzero","text":"Returns the first element of array which isn't zero (assumes elements are increasing and distinct)\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.frequency_to_time-Union{Tuple{FrequencySimulationResult{T,Dim,FieldDim}}, Tuple{T}, Tuple{FieldDim}, Tuple{Dim}} where T where FieldDim where Dim","page":"Base","title":"MultipleScattering.frequency_to_time","text":"Convert a FrequencySimulationResult into a TimeSimulationResult by using the inverse fourier transform. Assumes only positive frequencies and a real time signal\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.frequency_to_time-Union{Tuple{T}, Tuple{AbstractArray{Complex{T},N} where N,AbstractArray{T,1}}, Tuple{AbstractArray{Complex{T},N} where N,AbstractArray{T,1},AbstractArray{T,N} where N}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.frequency_to_time","text":"See also: DiscreteImpulse, ContinuousImpulse\n\nCalculates the time response from the frequency response by approximating an inverse Fourier transform. The time signal is assumed to be real and the frequenices ω_vec are assumed to be positive (can include zero) and sorted. The result is convoluted in time ωith the user specified impulse.\n\nWe use the Fourier transform convention: F(ω) =  ∫ f(t)exp(imωt) dt f(t) = (2π)^(-1) * ∫ F(ω)exp(-imωt) dt\n\nTo easily sample any time, the default is not FFT, but a discrete version of the transform above.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.t_to_ω-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.t_to_ω","text":"The inverse of ωtot if ω_vec[1] == 0\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.time_to_frequency-Union{Tuple{TimeSimulationResult{T,Dim,FieldDim}}, Tuple{T}, Tuple{FieldDim}, Tuple{Dim}} where T where FieldDim where Dim","page":"Base","title":"MultipleScattering.time_to_frequency","text":"Convert a TimeSimulationResult into a FrequencySimulationResult by using the fourier transform. Assumes only positive frequencies and a real time signal\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.time_to_frequency-Union{Tuple{T}, Tuple{Union{AbstractArray{T,N} where N, AbstractArray{Complex{T},N} where N},AbstractArray{T,1}}, Tuple{Union{AbstractArray{T,N} where N, AbstractArray{Complex{T},N} where N},AbstractArray{T,1},AbstractArray{T,N} where N}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.time_to_frequency","text":"The inverse of the function frequencytotime (only an exact inverse when using :DFT integration). We use the Fourier transform convention: F(ω) =  ∫ f(t)exp(imω*t) dt\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.ω_to_t-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T<:AbstractFloat","page":"Base","title":"MultipleScattering.ω_to_t","text":"returns an array of time from the frequency array ωvec. Uses the same convention for sampling the time as the discrete Fourier transfrom. Assumes ωvec is ordered and non-negative.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#simulation_base","page":"Base","title":"Simulation","text":"","category":"section"},{"location":"library/base/","page":"Base","title":"Base","text":"Simulation types and functions.","category":"page"},{"location":"library/base/","page":"Base","title":"Base","text":"FrequencySimulation\nrun(::FrequencySimulation)\nrun(::FrequencySimulation, ::Shape, ::AbstractVector)\nFrequencySimulationResult\nbasis_coefficients\nfield\nscattering_matrix\nt_matrix\nget_t_matrices","category":"page"},{"location":"library/base/#MultipleScattering.FrequencySimulation","page":"Base","title":"MultipleScattering.FrequencySimulation","text":"FrequencySimulation([particles::AbstractParticles=[],]\n                    source::AbstractSource)\n\nBuild a FrequencySimulation. If particles are not provided, an empty array is used.\n\nAfter building, you can run the simulation to get a FrequencySimulationResult.\n\n\n\n\n\n","category":"type"},{"location":"library/base/#Base.run-Tuple{FrequencySimulation}","page":"Base","title":"Base.run","text":"run(sim::FrequencySimulation, x, ω; basis_order=5)\n\nRun the simulation sim for the position x and angular frequency ω.\n\nPosition can be an SVector or Vector{SVector} and frequency can be a float or vector of floats.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#Base.run-Tuple{FrequencySimulation,Shape,AbstractArray{T,1} where T}","page":"Base","title":"Base.run","text":"run(sim::FrequencySimulation, region::Shape;\n    res=20, xres=res, yres=res, basis_order=5)\n\nRun the simulation sim for a grid of positions in region and for angular frequency ω.\n\nFrequency can be a float or vector of floats. The resolution of the grid points is defined by xres and yres.\n\n\n\n\n\n","category":"method"},{"location":"library/base/#MultipleScattering.FrequencySimulationResult","page":"Base","title":"MultipleScattering.FrequencySimulationResult","text":"Struct to hold results of a FrequencySimulation\n\n\n\n\n\n","category":"type"},{"location":"library/base/#MultipleScattering.basis_coefficients","page":"Base","title":"MultipleScattering.basis_coefficients","text":"basis_coefficients(sim::FrequencySimulation, ω::AbstractFloat; basis_order::Int=5)::Matrix{Complex}\n\nReturn coefficients for bases around each particle for a given simulation and angular frequency (ω).\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.field","page":"Base","title":"MultipleScattering.field","text":"field(result::SimulationResult, [i::Integer, j::Integer])\n\nGet field from result, optionally specifying indices.\n\nReturns single value of/matrix of complex SVectors() if vector field, and complex float if scalar field.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.scattering_matrix","page":"Base","title":"MultipleScattering.scattering_matrix","text":"Create the matrix S which will be inverted to find the scattering coefficients.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.t_matrix","page":"Base","title":"MultipleScattering.t_matrix","text":"t_matrix(particle, medium, ω, order)\n\nReturns a finite T-matrix, with size depending on order, for a specific particle within a medium with specific physical properties.\n\n\n\n\n\nt_matrix(Particle{2,Acoustic{T,2},Sphere{T,2}}, Acoustic{T,2}, ω, order)\n\nThe T-matrix for a 2D circlular acoustic particle in a 2D acoustic medium.\n\n\n\n\n\nt_matrix(Particle{2,Acoustic{T,2},Sphere{T,2}}, Acoustic{T,2}, ω, order)\n\nThe T-matrix for a 2D circlular Helmholtz resonator in a 2D acoustic medium.\n\n\n\n\n\nt_matrix(CapsuleParticle{2,Acoustic{T,2},Sphere{T,2}}, Acoustic{T,2}, ω, order)\n\nThe T-matrix for a 2D circlular capsule particle in an acoustic medium.\n\n\n\n\n\nt_matrix(Particle{3,Acoustic{T,3},Sphere{T,3}}, Acoustic{T,3}, ω, order)\n\nThe T-matrix for a 3D spherical acoustic particle in a 3D acoustic medium.\n\n\n\n\n\n","category":"function"},{"location":"library/base/#MultipleScattering.get_t_matrices","page":"Base","title":"MultipleScattering.get_t_matrices","text":"get_t_matrices(PhysicalMedium, Vector{Particles}, ω, basis_order::Integer)\n\nReturns vector of T-matrices from a vector of particles in a specific domain. Can save computation if multiple of the same kind of particle are present in the vector.\n\n\n\n\n\n","category":"function"},{"location":"example/moments/README/#StatisticalMoments","page":"StatisticalMoments","title":"StatisticalMoments","text":"","category":"section"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"DocTestSetup = quote\n    using MultipleScattering\nend","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"Here we are going to simulate the scattered wave for many different configurations of particles. We can then take the average and standard deviation (the moments) of the scattered wave. In statistical mechanics this process is called ensemble average.","category":"page"},{"location":"example/moments/README/#Region-and-particles-properties","page":"StatisticalMoments","title":"Region and particles properties","text":"","category":"section"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"First we choose the region to place particles and the receiver position:","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"using MultipleScattering\nbottomleft = [0.0;-25.0]\ntopright = [50.0;25.0]\nshape = Box([bottomleft, topright])\nx = [-10.0,0.0]","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"using Plots\nplot(shape);\nscatter!([x[1]],[x[2]], label=\"\");\nplot_shape = annotate!([(x[1], x[2] -2., \"Receiver\")])","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"(Image: Plot of shape and receiver)","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"Next we fill this shape with a random (uniform distribution) configuration of particles:","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"volfrac = 0.05\nradius = 1.0\n\nparticles = random_particles(Acoustic(2; ρ=0.0, c=0.0), Circle(radius);\n        region_shape = shape,\n        volume_fraction = volfrac,\n        seed=2\n);\n\nlength(particles)\n\n# output\n40","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"To see the position of the chosen particles:","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"plot(plot_shape)\nplot!(particles);\nplot!()","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"(Image: Plot particles)","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"Scattering a plane-wave from these particles  ","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"ωs = LinRange(0.01,1.0,100)\nplane_wave = plane_source(Acoustic(1.0, 1.0, 2);\n    direction = [1.0,0.0], position = x);","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"plot(run(particles, plane_wave,x,ωs))","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"(Image: )","category":"page"},{"location":"example/moments/README/#The-moments-of-the-scattered-wave","page":"StatisticalMoments","title":"The moments of the scattered wave","text":"","category":"section"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"Now we will do simulations for particles placed in many different configurations and take the moments:","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"results = map(1:20) do i\n    particles = random_particles(Acoustic(2; ρ=0.0, c=0.0), Circle(radius);\n            region_shape = shape,\n            volume_fraction = volfrac,\n            seed=i\n    )\n    run(FrequencySimulation(particles, plane_wave), x, ωs)\nend\n\n# package Plots changed it's argument, the below no longer works..\n# num_moments = 3\n# plot(results; field_apply = real, num_moments = num_moments)\n# plot!(xlabel=\"wavenumbers\", title=\"Moments of the real part\")","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"(Image: Moments of the real part the scattered waves)","category":"page"},{"location":"example/moments/README/#Calculate-the-moments-of-the-scattered-wave-in-time","page":"StatisticalMoments","title":"Calculate the moments of the scattered wave in time","text":"","category":"section"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"time_simulations = frequency_to_time.(results)\ntime_simulations[1].t # the time_arr chosen will be based on the discrete Fourier transform of simulations[1].k_arr\n# real_time_moments = StatisticalMoments(time_simulations; response_apply=real) # moments of the real part\n# plot(real_time_moments,xlims=(0,300));\n# plot!(xlabel=\"time\", title=\"Moments of the real part of the time wave\")","category":"page"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"(Image: Moments of the real part the scattered waves in time)","category":"page"},{"location":"example/moments/README/#References","page":"StatisticalMoments","title":"References","text":"","category":"section"},{"location":"example/moments/README/","page":"StatisticalMoments","title":"StatisticalMoments","text":"A. L. Gower, R. M. Gower, J. Deakin, W. J. Parnell, I. D. Abrahams, Learning about random media from near-surface backscattering: using machine learning to measure particle size and concentration, arXiv preprint, (2018)1801.05490","category":"page"},{"location":"manual/plot/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"manual/plot/","page":"Plotting","title":"Plotting","text":"The plotting for this package is supplied by the package Plots. The options and keywords used for the package Plots can be used for the plots in this package.","category":"page"},{"location":"manual/plot/","page":"Plotting","title":"Plotting","text":"Below are examples of plotting the whole field in frequency (harmonic wave) and time. The examples require the package Plots and, mostly, PyPlot.","category":"page"},{"location":"manual/plot/#Field-Harmonic-two-gaps","page":"Plotting","title":"Field - Harmonic two gaps","text":"","category":"section"},{"location":"manual/plot/","page":"Plotting","title":"Plotting","text":"using MultipleScattering\nusing Plots; gr(size = (800,300))\n\nradius = 1\nω = 2.0\n\nhost_medium = Acoustic(1.0, 1.0, 2)\nparticle_medium = Acoustic(0.0, 0.0, 2)\n\n# Create a wall of particles\nparticles = [\n  Particle(particle_medium, Sphere([0.,y],1.0))\nfor y = -40:2*radius:40.]\n\n# Make two gaps in the wall\ndeleteat!(particles,[18,19,23,24])\n\n# Define region to plot\nbottomleft = [-10.;-15.]\ntopright = [30.;15.]\nregion = Box([bottomleft, topright])\n\n# Calculating scattering for a plane wave\nsource =  plane_source(host_medium; direction = [1.0,0.0])\n\n# You can skip the step of defining FrequencySimulation\nresult = run(particles, source, region, [ω]; res=100)\n\nplot(result,ω;\n    field_apply = abs, seriestype = :heatmap,\n    title = \"Absolute value\"\n  );\np1 = plot!(particles, ylims = (-15.0,15.0));  \nplot(result,ω;\n    field_apply = real, seriestype = :heatmap,\n    title = \"Real part\"\n);\np2 = plot!(particles, ylims = (-15.0,15.0));\nplot(p1, p2)\n\n# savefig(\"gap-diffraction.png\")","category":"page"},{"location":"manual/plot/","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"manual/plot/#Movie-Harmonic-two-gaps","page":"Plotting","title":"Movie - Harmonic two gaps","text":"","category":"section"},{"location":"manual/plot/","page":"Plotting","title":"Plotting","text":"Continuing from Field - Harmonic two gaps, the previous example, we can plot how the harmonic field oscillates in time. That is, to get the harmonic field at time t we just multiple the field by mathrm e^-mathrm i omega t for every mathbf x. For example, the plane wave mathrm e^mathrm i x k would become mathrm e^mathrm i x k -mathrm i omega t.   ","category":"page"},{"location":"manual/plot/","page":"Plotting","title":"Plotting","text":"gr(size = (450,300))\n\nts = LinRange(0.,2pi/ω,30)\n\nmaxc = round(10*maximum(real.(field(result))))/10\nminc = round(10*minimum(real.(field(result))))/10\n\nanim = @animate for t in ts\n    plot(result,ω; seriestype = :heatmap,\n        phase_time=t, clim=(minc,maxc),\n        ylims = (-15.0,15.0) , c=:balance\n    )\n    plot!(particles)\n    plot!(colorbar=false, title=\"\",axis=false, xguide =\"\",yguide =\"\")\nend\n# gif(anim,\"gap-diffraction.gif\", fps = 7)","category":"page"},{"location":"manual/plot/","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"manual/plot/#Movie-Time-impulse-plane-wave-two-gaps","page":"Plotting","title":"Movie - Time impulse plane-wave - two gaps","text":"","category":"section"},{"location":"manual/plot/","page":"Plotting","title":"Plotting","text":"Continuing from Field - Harmonic two gaps, we can plot how an impulse plave-wave in time passes through two gaps. See Time response for more details on the code used below.","category":"page"},{"location":"manual/plot/","page":"Plotting","title":"Plotting","text":"gr(size = (450,300))\nωs = LinRange(0.0,2.0,300)[2:end] # avoid using ω = 0\n\n# We use a lower resolution (resolution = 50) as this is a heavier calculation\nresult = run(particles, source, region, ωs; res = 50)\n\n# Calculate time response over rect\nt_max = 0.75 .* real(region.dimensions[1] / host_medium.c)\nts = LinRange(0.0,t_max,75)\nimpulse = GaussianImpulse(maximum(ωs)*0.6)\ntimres = frequency_to_time(result; t_vec = ts, impulse = impulse)\n\nmaxc = round(10*maximum(field(timres)))/10\nminc = round(10*minimum(field(timres)))/10\n\n# timres = TimeSimulationResult(timres.field .+ max_c/100.0 , timres.x, timres.t)\n\nylimits =  (-region.dimensions[2]/2,region.dimensions[2]/2)\nanim = @animate for t in ts\n    plot(timres,t, seriestype=:heatmap,\n      clim = (minc, maxc),\n      leg = false, ylims = ylimits\n    )\n    plot!(particles)\n    plot!(frame = :none, title=\"\", xguide =\"\",yguide =\"\")\nend\n\n# gif(anim,\"gap-diffraction.gif\", fps = 7)","category":"page"},{"location":"manual/plot/","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"manual/plot/#Movie-Harmonic-from-random-particles","page":"Plotting","title":"Movie - Harmonic from random particles","text":"","category":"section"},{"location":"manual/plot/","page":"Plotting","title":"Plotting","text":"using MultipleScattering\nusing Plots;\n\nnum_particles = 70\nradius = 1.0\nω = 1.0\n\nhost_medium = Acoustic(1.0, 1.0, 2)\nparticle_medium = Acoustic(0.2, 0.3, 2)\nparticle_shape = Circle(radius)\n\nmax_width = 50*radius\nbottomleft = [0.,-max_width]\ntopright = [max_width,max_width]\nshape = Box([bottomleft,topright])\n\nparticles = random_particles(particle_medium, particle_shape; region_shape = shape, num_particles = num_particles)\n\nsource =  plane_source(host_medium; direction = [1.0,0.5])\n\nsimulation = FrequencySimulation(particles, source)\n\nbottomleft = [-25.,-max_width]\nbounds = Box([bottomleft,topright])\nresult = run(simulation, bounds, [ω]; res=100)\n\nts = LinRange(0.,2pi/ω,30)\n\nmaxc = round(10*maximum(real.(field(result))))/10\nminc = round(10*minimum(real.(field(result))))/10\n\nanim = @animate for t in ts\n    plot(result,ω; seriestype = :heatmap, phase_time=t, clim=(minc,maxc), c=:balance)\n    plot!(simulation)\n    plot!(colorbar=false, title=\"\",axis=false, xguide =\"\",yguide =\"\")\nend\n# gif(anim,\"backscatter_harmonic.gif\", fps = 7)","category":"page"},{"location":"manual/plot/","page":"Plotting","title":"Plotting","text":"(Image: backscattering from harmonic wave)","category":"page"},{"location":"example/time_response_single_particle/README/#Time-response-from-single-particle","page":"Time response from single particle","title":"Time response from single particle","text":"","category":"section"},{"location":"library/acoustics/#Acoustic","page":"Acoustic","title":"Acoustic","text":"","category":"section"},{"location":"library/acoustics/","page":"Acoustic","title":"Acoustic","text":"CurrentModule = MultipleScattering","category":"page"},{"location":"library/acoustics/","page":"Acoustic","title":"Acoustic","text":"Acoustic type and functions.","category":"page"},{"location":"library/acoustics/","page":"Acoustic","title":"Acoustic","text":"Modules = [MultipleScattering]\nOrder   = [:constant, :type, :function]\nPages   = [\"src/physics/acoustics/acoustics.jl\", \"src/physics/acoustics/circle.jl\", \"src/physics/acoustics/sphere.jl\", \"src/physics/acoustics/source.jl\", \"src/physics/acoustics/boundary_data.jl\"]","category":"page"},{"location":"library/acoustics/#MultipleScattering.Acoustic","page":"Acoustic","title":"MultipleScattering.Acoustic","text":"Acoustic{T<:AbstractFloat,Dim}(ρ::T, c::Complex{T})\nAcoustic(ρ::T, c::Union{T,Complex{AbstractFloat}}, Dim::Integer)\n\nPhysical properties for a homogenous isotropic acoustic medium with wavespeed (c) and density (ρ)\n\nSimulations in this medium produce scalar (1D) fields in Dim dimensions.\n\n\n\n\n\n","category":"type"},{"location":"library/acoustics/#MultipleScattering.check_material-Tuple{Particle,Acoustic}","page":"Acoustic","title":"MultipleScattering.check_material","text":"check_material(p::Particle, outer_medium::Acoustic)\n\nChecks if wave scattering from the particle p is physically viable given the material properties of p and its surrounding medium outer_medium.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.hard-Union{Tuple{Acoustic{T,Dim}}, Tuple{T}, Tuple{Dim}} where T where Dim","page":"Acoustic","title":"MultipleScattering.hard","text":"hard(host_medium::Acoustic)\n\nSee sound_hard.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.impedance-Tuple{Acoustic}","page":"Acoustic","title":"MultipleScattering.impedance","text":"impedance(medium::Acoustic)\n\nCharacteristic specific acoustic impedance (z₀) of medium\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.internal_field-Union{Tuple{T}, Tuple{Dim}, Tuple{AbstractArray{T,1},Particle{Dim,Acoustic{T,Dim},S} where S<:Shape,RegularSource{Acoustic{T,Dim},S} where S<:AbstractSymmetry,T,AbstractArray{Complex{T},1}}} where T where Dim","page":"Acoustic","title":"MultipleScattering.internal_field","text":"internal_field(x::AbstractVector, p::Particle{Dim,Acoustic{T,Dim}},  source::RegularSource, ω::T, scattering_coefficients::AbstractVector{Complex{T}})\n\nThe internal field for an acoustic particle in an acoustic medium. For a sphere and circular cylinder the result is exact, for everything else it is an approximation which assumes smooth fields.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.pressure_release-Union{Tuple{Acoustic{T,Dim}}, Tuple{T}, Tuple{Dim}} where T where Dim","page":"Acoustic","title":"MultipleScattering.pressure_release","text":"pressure_release(host_medium::Acoustic)\n\nSee sound_soft.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.rigid-Union{Tuple{Acoustic{T,Dim}}, Tuple{T}, Tuple{Dim}} where T where Dim","page":"Acoustic","title":"MultipleScattering.rigid","text":"rigid(host_medium::Acoustic)\n\nSee sound_hard.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.soft-Union{Tuple{Acoustic{T,Dim}}, Tuple{T}, Tuple{Dim}} where T where Dim","page":"Acoustic","title":"MultipleScattering.soft","text":"soft(host_medium::Acoustic)\n\nSee sound_soft.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.sound_hard-Tuple{Type,Integer}","page":"Acoustic","title":"MultipleScattering.sound_hard","text":"sound_hard([T::Type = Float64,] Dim::Integer)\n\nConstruct physical properties of a sound hard acoustic object with type T and dimension Dim. Also known as rigid and equivalent to a zero_neumann pressure boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.sound_soft-Tuple{Type,Integer}","page":"Acoustic","title":"MultipleScattering.sound_soft","text":"sound_soft([T::Type = Float64,] Dim::Integer)\n\nConstruct physical properties of a sound hard acoustic object with type T and dimension Dim. Equivalent to a zero_dirichlet pressure boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.zero_dirichlet-Union{Tuple{Acoustic{T,Dim}}, Tuple{T}, Tuple{Dim}} where T where Dim","page":"Acoustic","title":"MultipleScattering.zero_dirichlet","text":"zero_dirichlet(host_medium::Acoustic)\n\nSee sound_soft.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.zero_neumann-Union{Tuple{Acoustic{T,Dim}}, Tuple{T}, Tuple{Dim}} where T where Dim","page":"Acoustic","title":"MultipleScattering.zero_neumann","text":"zero_neumann(host_medium::Acoustic)\n\nSee sound_hard.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.t_matrix-Union{Tuple{T}, Tuple{Particle{2,Acoustic{T,2},Sphere{T,2}},Acoustic{T,2},T,Integer}} where T<:AbstractFloat","page":"Acoustic","title":"MultipleScattering.t_matrix","text":"t_matrix(Particle{2,Acoustic{T,2},Sphere{T,2}}, Acoustic{T,2}, ω, order)\n\nThe T-matrix for a 2D circlular acoustic particle in a 2D acoustic medium.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.t_matrix-Union{Tuple{T}, Tuple{Particle{3,Acoustic{T,3},Sphere{T,3}},Acoustic{T,3},T,Integer}} where T<:AbstractFloat","page":"Acoustic","title":"MultipleScattering.t_matrix","text":"t_matrix(Particle{3,Acoustic{T,3},Sphere{T,3}}, Acoustic{T,3}, ω, order)\n\nThe T-matrix for a 3D spherical acoustic particle in a 3D acoustic medium.\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.plane_source-Union{Tuple{T}, Tuple{Acoustic{T,2},AbstractArray{T,N} where N}, Tuple{Acoustic{T,2},AbstractArray{T,N} where N,AbstractArray{T,N} where N}, Tuple{Acoustic{T,2},AbstractArray{T,N} where N,AbstractArray{T,N} where N,Union{Complex{T}, T}}} where T","page":"Acoustic","title":"MultipleScattering.plane_source","text":"plane_source(medium::Acoustic, source_position, source_direction=[1,0], amplitude=1)::RegularSource\n\nCreate an Acoustic planar wave RegularSource\n\n\n\n\n\n","category":"method"},{"location":"library/acoustics/#MultipleScattering.point_source-Union{Tuple{T}, Tuple{Acoustic{T,2},AbstractArray{T,1} where T}, Tuple{Acoustic{T,2},AbstractArray{T,1} where T,Union{Complex{T}, Function, T}}} where T<:AbstractFloat","page":"Acoustic","title":"MultipleScattering.point_source","text":"point_source(medium::Acoustic, source_position, amplitude=1)::RegularSource\n\nCreate 2D Acoustic point RegularSource (zeroth Hankel function of first type)\n\n\n\n\n\n","category":"method"},{"location":"manual/source/#RegularSources","page":"RegularSources","title":"RegularSources","text":"","category":"section"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"DocTestSetup = quote\n    using MultipleScattering\nend","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"RegularSource is a struct which represents any source, also called an incident wave. See RegularSource for a list of relevant types and functions.","category":"page"},{"location":"manual/source/#Acoustics","page":"RegularSources","title":"Acoustics","text":"","category":"section"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"For acoustics, any wave field u_textin(xy) that satisfies nabla^2 u_textin(xy) + k^2 u_textin(xy) = 0, with k = dfracomegac, can be a source.","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"Two commonly used sources are a plane wave and point source. These can then be added together to create more complicated sources, like immitating a finite sized transducer / source.","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"For a plane-wave of the form u_textin(xy) = A mathrm e^mathrm i k mathbf n cdot (mathbf x - mathbf x_0), where A is the amplitude, mathbf n = (n_1n_2n_2) is unit vector which points in the direction of propagation, and mathbf x_0 = (x_0y_0z_0) is the initially position (or origin) of the source, we can use","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"julia> using MultipleScattering;\n\njulia> dimension = 3;\n\njulia> medium = Acoustic(dimension; ρ = 1.0, c = 1.0);\n\njulia> A = 1.0;\n\njulia> n = [1.0, 1.0, 1.0];\n\njulia> x0 = [1.0, 0.0, 0.0];\n\njulia> plane_wave = plane_source(medium; amplitude = A, direction = n, position = x0);\n","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"We can plot this source wave one frequency ω by using","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"julia> ω = 1.0;\n\njulia> plot_origin = zeros(3); plot_dimensions = 2 .* ones(3);\n\njulia> plot_domain = Box(plot_origin, plot_dimensions);\n\njulia> using Plots; pyplot();\n\njulia> plot(plane_wave, ω; region_shape = plot_domain, y = 0.0) # in 3d currently only x-z slices are plotted for a given fixed y","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"(Image: Plot plane wave)","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"Another useful source is the point source. In any dimension we consider the point source to be the zero order of the outgoing_basis_function, which are the basis for all outgoing waves.","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"The point source for 2D is u_textin(xy) = fracmathrm i A4 mathrm H_0^(1)(k (x-x_0y-y_0)) and for for 3D it is u_textin(xy) = fracA4 pi frace^i k   x -  x_0) x -  x_0 where A is the amplitude,  mathbf x_0 is the origin of the point source, and mathrm H_0^(1) is the Hankel function of the first kind.","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"julia> x0 = [0.0,-1.2, 0.0];\n\njulia> point_wave = point_source(medium, x0, A);\n","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"julia> plot(point_wave, ω; region_shape = plot_domain)","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"(Image: Plot point wave)","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"NOTE: Because the point source has a singularity at x_0 it is best to avoid plotting, and evaluating the field, close to x_0. ","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"This can be achieved by using run(point_wave, ω; region_shape = plot_domain, exclude_region=some_region) or plot(point_wave, ω; region_shape = plot_domain, exclude_region=some_region) both of which rely on the function points_in_shape.","category":"page"},{"location":"manual/source/#Creating-new-sources","page":"RegularSources","title":"Creating new sources","text":"","category":"section"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"The easiest way to create new sources is to just sum together predefined sources:","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"julia> source = (3.0 + 1.0im) * point_wave + plane_wave;\n\njulia> plot(source, ω; bounds = plot_domain)","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"(Image: Plot combined source wave)","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"For example, we can use this to create a finite emitter/transducer source,","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"julia> xs = LinRange(-0.7, 0.7, 30);\n\njulia> source = sum(xs) do x point_source(medium, [x, 0.0, -1.1]) end;\n","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"julia> plot(source, 4.0; y = 0.0, bounds = plot_domain, field_apply = abs, resolution = 40)","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"(Image: Plot point wave)","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"where field_apply is applied to the wave field at every point, the default is field_apply = real, and res is the resolution along both the x and y axis. Note, this is not computationally very efficient. See source.jl for the very abstract code behind the scenes.","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"To define a new source you will need to understand the internals below.","category":"page"},{"location":"manual/source/#RegularSource-internals","page":"RegularSources","title":"RegularSource internals","text":"","category":"section"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"The struct RegularSource has three fields: medium, field, and coef, explained with examples below:","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"julia> plane_wave = plane_source(Acoustic(1.0, 1.0, 2); direction = [1.0,0.0]);\n\njulia> plane_wave.medium # the physical medium\nAcoustic(1.0, 1.0 + 0.0im, 2)\n\njulia> x = [1.0, 1.0]; ω = 1.0;\n\njulia> plane_wave.field(x,ω) # the value of the field\n0.5403023058681398 + 0.8414709848078965im","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"To calculate the scattering from a particle due to a source, we need the coefficients a_n(mathbf x_0 omega) = textRegularSourcecoefficients(n x0 ω) We use these coefficients to represent the source in a radial coordinate system. That is, for any origin mathbf x_0, we need to represent the incident wave u_textin(mathbf x) using a series or regular waves","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"u_textin(mathbf x) = sum_n a_n (mathbf x_0 omega) mathrm v_n (mathbf x - mathbf x_0)","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"where for the scalar wave equation:","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"$","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"\\mathrm v{n} (\\mathbf x) = \\begin{cases}    \\mathrm J{n}(k r) \\mathrm e^{\\mathrm i \\theta n} & \\text{for } \\mathbf x \\in \\mathbb R^2, \\\n   \\mathrm j{\\ell}(k r) \\mathrm Y{\\ell}^m (\\hat{\\mathbf x}) & \\text{for } \\mathbf x \\in \\mathbb R^3, \\\n\\end{cases} $","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"where for the first case (rtheta) are the polar coordinates and n sums over -N-N+1 cdots N, where N is the basis order, and mathrm J_n is a Bessel function. For the second case, we use a spherical coordinates with r =  mathbf x and hatmathbf x = mathbf xmathbf x, n denotes the multi-index n=ellm with summation over ell = 0 1 cdotsN and m=-ell-ell+1ell, mathrm j_ell is a spherical Bessel function, and mathrm Y_ell^m is a spherical harmonic.","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"Both the inbuilt plane and point sources have functions coef which satisfy the above identity, for example","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"julia> using LinearAlgebra, SpecialFunctions;\n\njulia> medium = Acoustic(2.0, 0.1, 2);\n\njulia> source = plane_source(medium);\n\njulia> x0 = [1.0, 1.0]; ω = 0.9;\n\njulia> x = x0 + 0.1*rand(2); basis_order = 10;\n\njulia> vs = regular_basis_function(medium, ω);\n\njulia> source.field(x, ω) ≈ sum(source.coefficients(basis_order, x0, ω) .* vs(basis_order, x - x0))\ntrue","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"The package also supplies a convenience function source_expand, which represents the source in terms of regular waves, for example:  ","category":"page"},{"location":"manual/source/","page":"RegularSources","title":"RegularSources","text":"julia> source2 = source_expand(source, x0; basis_order = 10);\n\njulia> source.field(x, ω) ≈ source2(x, ω)\ntrue","category":"page"},{"location":"manual/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"manual/intro/#into_physical_properties","page":"Introduction","title":"Physical properties wave","text":"","category":"section"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"First define the host medium, for example for an acoustic medium in 2D","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using MultipleScattering\nend","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"julia> using MultipleScattering;\n\njulia> spatial_dim = 2; # could also be 3, but then all 2D vectors below would need to be 3D\n\njulia> host_medium = Acoustic(spatial_dim; ρ = 1.0, c = 1.0) # density ρ = 1.0 and soundspeed c = 1.0\nAcoustic(1.0, 1.0 + 0.0im, 2)","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"At this step we have restricted the physics to acoustics, that is, solutions to the Helmholtz equation: nabla^2 u(xyomega) + k^2 u(xyomega) = 0, where k = dfracomegac, omega is the angular frequency and c the sound speed of the medium.","category":"page"},{"location":"manual/intro/#into_source","page":"Introduction","title":"RegularSource wave","text":"","category":"section"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"The host medium will determine the types of waves that can propagate. For example an incident plane wave mathrm e^ mathrm i k x there is a convenient constructor","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"julia> source = plane_source(host_medium; direction = [1.0, 0.0]);\n","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nOften mathrm e^ mathrm i k x - mathrm i omega t is considered to be a harmonic plane-wave travelling along the x-axis. We omit the part $ - \\mathrm i \\omega t$ as is common in frequency space.","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"We generally call the incident wave a source. See RegularSources for details, and see Acoustic for some functions for the Acoustic medium.","category":"page"},{"location":"manual/intro/#into_particles","page":"Introduction","title":"Particles","text":"","category":"section"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"Next, we define some particles to scatter an acoustic wave. We choose two filled circles, the first centred at [-2, 2] with radius 2 and the second at [-2, -2] with radius 0.5,","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"julia> particle_medium =  Acoustic(spatial_dim; ρ = 10.0, c = 2.0); # 2D acoustic particle with density ρ = 10.0 and soundspeed c = 2.0\n\njulia> p1 = Particle(particle_medium, Sphere([-2.0, 2.0], 2.0));\n\njulia> p2 = Particle(particle_medium, Sphere([-2.0, -2.0], 0.5));\n\njulia> particles = [p1, p2];\n","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"See Shapes and Particles for details on different shapes and particles.","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"If you have the package Plots installed you can plot the particles. Note that although they appear hollow, we consider them to filled with the same homogenous material.","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"julia> using Plots;\n\njulia> plot(particles)","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nMost things in this package can be plotted just by typing plot(thing). However you need to have Plots installed, and you may need to use the backend pyplot(). See Plotting for details on plotting.","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"(Image: Plot of response against wavenumber)","category":"page"},{"location":"manual/intro/#Simulation-and-results","page":"Introduction","title":"Simulation and results","text":"","category":"section"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"Once we know the medium, the particles, and the have these three components, we can build our FrequencySimulation object","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"julia> simulation = FrequencySimulation(particles, source);\n","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"To get numerical results, we run our simulation for specific positions and angular frequencies,","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"julia> x = [[-10.0, 0.0], [0.0, 0.0]];\n\njulia> max_ω = 1.0;\n\njulia> ωs = 0.01:0.01:max_ω;\n\njulia> result = run(simulation, x, ωs);\n","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"We can plot the time-harmonic response across the frequencies ωs wavenumbers and at the location (-10,0) by typing:","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"julia> plot(result)","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"(Image: Plot of response against wavenumber)","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"For a better overview you can calculate the response for lots of points x in the domain and then plot the whole field for one frequency ω by typing:","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"julia> ω = 0.8;\n\njulia> plot(simulation, ω);\n\njulia> plot!(particles)","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"(Image: Plot real part of acoustic field)","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"For details on plot fields and videos see Plotting.","category":"page"},{"location":"manual/intro/#Results-in-time","page":"Introduction","title":"Results in time","text":"","category":"section"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"If we have calculated a frequency response hat u(omega) over a range of frequencies omega, then we can use a Fourier transform to calculate the response in time u(t). That is, we can calculate u(t) by approximating the Fourier transform:","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"u(t) = frac12pi int_-infty^infty hat u(omega)mathrm e^-mathrm i omega t domega","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"For details see the section on Time response. For example, taking a Discrete Fourier transform of the previous response leads to an incident plane wave pulse in time:","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"julia> time_result = frequency_to_time(result);\n\njulia> plot(time_result)","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"(Image: Plot real part of acoustic field)","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"In the image above the first peak on the left is due to the incident wave (the source), and the second peak is the wave scattered by theparticles. Note how both peaks are quite jagged. This is due to Gibb's phenomena. To resolve this we can use a Gaussian impulse function shown below. See Time response for more details.","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"julia> t_vec = LinRange(0.,700.,400);\n\njulia> gauss_time_result = frequency_to_time(result; t_vec = t_vec, impulse = GaussianImpulse(max_ω));\n\njulia> plot(gauss_time_result)","category":"page"},{"location":"manual/intro/","page":"Introduction","title":"Introduction","text":"(Image: Plot real part of acoustic field)","category":"page"},{"location":"example/README/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"example/README/#[Simple-random-particles](random_particles/README.md)","page":"Overview","title":"Simple random particles","text":"","category":"section"},{"location":"example/README/","page":"Overview","title":"Overview","text":"Simple example of random particles in rectangle","category":"page"},{"location":"example/README/#[Random-particles-in-a-circle](particles_in_circle/README.md)","page":"Overview","title":"Random particles in a circle","text":"","category":"section"},{"location":"example/README/","page":"Overview","title":"Overview","text":"Generate random particles in a circle","category":"page"},{"location":"example/README/#[StatisticalMoments](moments/README.md)","page":"Overview","title":"StatisticalMoments","text":"","category":"section"},{"location":"example/README/","page":"Overview","title":"Overview","text":"How to extract statistical information from a batch of simulations, in this case: mean, standard deviation, skew and kurtosis (also known as moments).","category":"page"},{"location":"example/README/#[Near-surface-backscattering](near_surface_backscattering/README.md)","page":"Overview","title":"Near surface backscattering","text":"","category":"section"},{"location":"example/README/","page":"Overview","title":"Overview","text":"A method to calculate the backscattering from an infinite halfspace.\nSee backscattering in frequency and time.","category":"page"},{"location":"manual/new_types/#New-particles","page":"New particles","title":"New particles","text":"","category":"section"},{"location":"manual/new_types/","page":"New particles","title":"New particles","text":"If you are feeling very adventurous, you can define a new type of particle.","category":"page"},{"location":"manual/new_types/","page":"New particles","title":"New particles","text":"A particle is define by its shape and physical properties. The simplest example being a circular acoustics particle: Particle(Acoustic(1.0,1.0,2),Circle(1.0)). To define a new particle you need to either use a new shape or a new physical medium.","category":"page"},{"location":"manual/new_types/#New-shape","page":"New particles","title":"New shape","text":"","category":"section"},{"location":"manual/new_types/","page":"New particles","title":"New particles","text":"Suppose we want to define a new shape, which is very much like a rectangle.","category":"page"},{"location":"manual/new_types/","page":"New particles","title":"New particles","text":"using MultipleScattering\n\nstruct MyRectangle{T} <: Shape{2}\n    origin::Vector{T}\n    width::T\n    height::T\nend","category":"page"},{"location":"manual/new_types/","page":"New particles","title":"New particles","text":"To be able to place particles in MyRectangle you need to extend the functions defined in the package you need to explicitly import them:","category":"page"},{"location":"manual/new_types/","page":"New particles","title":"New particles","text":"import MultipleScattering: volume, name, bounding_box\n\nvolume(shape::MyRectangle) = shape.width * shape.height\nname(shape::MyRectangle) = \"MyRectangle\"\n\n# every shape needs a bounding rectangle, this is where particles are first placed.\nbounding_box(shape::MyRectangle) = Box(shape.origin, [shape.width, shape.height])\n\nimport Base.in, Base.issubset\nfunction in(x::AbstractVector, r::MyRectangle)::Bool\n    all(abs.(x .- r.origin) .<= [r.width, r.height])\nend\n\nfunction issubset(circle::Sphere{T,2}, r::MyRectangle{T}) where {T}\n    all((origin(circle) .- circle.radius) .>= r.origin - [r.width/2.0, r.height/2.0]) &&\n    all((origin(circle) .+ circle.radius) .<= r.origin + [r.width/2.0, r.height/2.0])\nend","category":"page"},{"location":"manual/new_types/","page":"New particles","title":"New particles","text":"note: Note\nUsing other packages with MultipleScattering may result in a naming conflict for functions like volume. In this case you will have to explicitly call MultipleScattering.volume.","category":"page"},{"location":"manual/new_types/","page":"New particles","title":"New particles","text":"With these definitions you can now fill this shape with circular particles, as shown in Placing particles in a region.","category":"page"},{"location":"manual/new_types/","page":"New particles","title":"New particles","text":"To define a new particle from MyRectangle you need to extend the functions outer_radius, Base.(==), iscongruent, then supposing you will use a predefined PhysicalProperty (such as Acoustic), you then need to extend t_matrix.","category":"page"},{"location":"#MultipleScattering.jl-Documentation","page":"Home","title":"MultipleScattering.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia library for simulating, processing, and plotting multiple scattering of acoustic waves.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The library uses the multipole method to solve the Helmholtz equation (time-harmonic waves). The multipole method is particularly efficient at solving scattering problems for particles in an infinite domain. This library is configured to use T-matrices to represent scattering from particles with any shape and properties. The package is setup to deal with different spatial dimensions and types of waves which satisfy Helmholtz equation's, e.g. acoustics, electromagnetism, elasticity. For details on some of the maths see Martin (1995) and Gower et al. (2017).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install Julia v1.0 or later, then run","category":"page"},{"location":"","page":"Home","title":"Home","text":"] # to enter the package mode\nadd MultipleScattering","category":"page"},{"location":"","page":"Home","title":"Home","text":"Press backspace to exit the package mode.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can learn to use this package through examples or through our manual, which starts with a simple Introduction.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"base.md\", \"acoustics.md\",\"random.md\"]\nDepth = 2","category":"page"},{"location":"library/random/#Random","page":"Random","title":"Random","text":"","category":"section"},{"location":"library/random/","page":"Random","title":"Random","text":"CurrentModule = MultipleScattering","category":"page"},{"location":"library/random/#Random-particles","page":"Random","title":"Random particles","text":"","category":"section"},{"location":"library/random/","page":"Random","title":"Random","text":"random_particles","category":"page"},{"location":"library/random/#MultipleScattering.random_particles","page":"Random","title":"MultipleScattering.random_particles","text":"random_particles(particle_medium, particle_shapes::Vector{Shape}, region_shape, volume_fraction::Number;\n    seed=Random.make_seed())\nrandom_particles(particle_medium, particle_shape::Shape, region_shape, volume_fraction::Number;\n    seed=Random.make_seed())\nrandom_particles(particle_medium, particle_shape::Shape, region_shape, N::Integer;\n    seed=Random.make_seed())\n\nGenerate N random particles that fit inside region_shape (or fill with volume_fraction)\n\nSpecify seed to make output deterministic. Algorithm places particles unifomly randomly inside the bounding box of region_shape and discards particle if it overlaps (based on outer radius) or does not lies completely in box.\n\nWhen passing particle_shapes::Vector{Shape} we assume each element is equally likely to occur. Repeating the same shape will lead to it being placed more often.\n\n\n\n\n\n","category":"function"},{"location":"library/random/#Moments","page":"Random","title":"Moments","text":"","category":"section"},{"location":"library/random/","page":"Random","title":"Random","text":"statistical_moments","category":"page"},{"location":"library/random/#MultipleScattering.statistical_moments","page":"Random","title":"MultipleScattering.statistical_moments","text":"statistical_moments(results, n; field_apply=real)::Vector{Matrix}\n\nCalculate moments up to n of results at each position and wavenumber/time, after applying field_apply.\n\n\n\n\n\n","category":"function"}]
}

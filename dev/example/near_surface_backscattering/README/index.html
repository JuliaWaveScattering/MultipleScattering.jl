<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Near-surface backscattering · MultipleScattering.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MultipleScattering.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../../base/">Base</a></li><li><a class="toctext" href="../../../acoustics/">Acoustic</a></li><li><a class="toctext" href="../../../random/">Random</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../box_size/README/">Box size</a></li><li><a class="toctext" href="../../hankel_convergence/README/">Convergence when increasing the number of Hankel functions</a></li><li><a class="toctext" href="../../intro/README/">Go to introductory example.</a></li><li><a class="toctext" href="../../lens/README/">Lens</a></li><li><a class="toctext" href="../../moments/README/">StatisticalMoments</a></li><li class="current"><a class="toctext" href>Near-surface backscattering</a><ul class="internal"><li><a class="toctext" href="#Generate-a-large-material-filled-with-particles.-1">Generate a large material filled with particles.</a></li><li><a class="toctext" href="#Calculate-backscattering-for-different-quantity-of-particles-1">Calculate backscattering for different quantity of particles</a></li><li><a class="toctext" href="#Calculate-backscattering-in-time-1">Calculate backscattering in time</a></li><li><a class="toctext" href="#Calculate-backscattering-only-from-near-surface-particles-1">Calculate backscattering only from near-surface particles</a></li></ul></li><li><a class="toctext" href="../../random_particles/README/">Simple random particles example</a></li><li><a class="toctext" href="../../random_particles_in_circle/README/">Random particles in a circle</a></li><li><a class="toctext" href="../../shapes/README/">Shapes</a></li><li><a class="toctext" href="../../time_response_single_particle/README/">Time response from single particle</a></li><li><a class="toctext" href="../../two_particles/README/">Two particles</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href>Near-surface backscattering</a></li></ul><a class="edit-page" href="https://github.com/jondea/MultipleScattering.jl/blob/master/docs/src/example/near_surface_backscattering/README.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Near-surface backscattering</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Near-surface-backscattering-1" href="#Near-surface-backscattering-1">Near-surface backscattering</a></h1><p>Near-surface backscattering is a method of accurately calculating the backscattering from an infinite halfspace. First, let us see why it is difficult to approximate the scattering from a halfspace filled with particles. That is, let us find out how many particles are required before the backscattering converges.</p><h2><a class="nav-anchor" id="Generate-a-large-material-filled-with-particles.-1" href="#Generate-a-large-material-filled-with-particles.-1">Generate a large material filled with particles.</a></h2><pre><code class="language-julia">using MultipleScattering
using Plots
pyplot(linewidth=2)

radius = 0.8
volfrac = 0.10
max_width = 60.

bottomleft = [0.,-max_width]
topright = [max_width,max_width]

shape = Rectangle(bottomleft,topright)
particles = random_particles(volfrac, radius, shape; c=1.0+0.0im, ρ=0.0)</code></pre><p>We will measure the backscattering at <code>listener_position</code>:</p><pre><code class="language-julia">listener_position = [-10.,0.]
scatter([listener_position[1]],[listener_position[2]]);
annotate!([(listener_position[1], listener_position[2] -max_width/10., &quot;Receiver&quot;)])
plot!.(particles);
plot!(shape)</code></pre><p><img src="../big_box.png" alt="The largest quantity of particles used"/></p><h2><a class="nav-anchor" id="Calculate-backscattering-for-different-quantity-of-particles-1" href="#Calculate-backscattering-for-different-quantity-of-particles-1">Calculate backscattering for different quantity of particles</a></h2><p>We will shave off particles on the right of this group of particles (above), and then calculate the resulting backscattered waves.</p><pre><code class="language-julia">widths = 10.:10.:max_width # choose the width of the region filled with particles
k_arr = collect(0.01:0.01:1.) # choose the wavenumbers of the incident wave

simulations = map(widths) do w # this is a for loop over the array widths
    shape.topright[1] = w # choose a material with a smaller width
    ps = filter(p -&gt; p⊆shape, particles) # shave off particles
    FrequencySimulation(ps, k_arr) # calculate backscattering
end

backscattered_waves = [s.response for s in simulations]
num_particles = [length(s.particles) for s in simulations]

M = length(backscattered_waves)
bM = backscattered_waves[M] # backscattering from largest material
differences = [norm(b - bM) for b in backscattered_waves[1:(M-1)]]./norm(bM)

plot_converge = plot(num_particles[1:(M-1)], differences, xlabel = &quot;number of particles&quot;, ylabel =&quot;error %&quot;, label=&quot;frequency convergence&quot;)</code></pre><p><img src="../freq_convergence.png" alt="The convergence of the response in frequency, when increasing the number of particles"/></p><p>The graph shows the rate of convergence, that is, how much the backscattering changes when including more particles (making the material deeper). The graph has not clearly converged, so we can only conclude that more than 400 particles are needed to accurately approximate the backscattering from an infinite halfspace. </p><p>We can accelerate this convergence by considering backscattering in time.</p><h2><a class="nav-anchor" id="Calculate-backscattering-in-time-1" href="#Calculate-backscattering-in-time-1">Calculate backscattering in time</a></h2><pre><code class="language-julia">time_simulations = TimeSimulation.(simulations)

times = 2*(widths[1:5] .- listener_position[1]) # time if takes for an incident plane wave to reach the furthest particles and then return to the receiver

plot()
for i in [1,3,6,9,12,13]
    plot!(time_simulations[i],label=&quot;$(num_particles[i]) particles&quot;
        , xlims=(0,maximum(times)+10.), ylims=(-0.6,0.3)
        , xticks = [0.; 30.; times]
    )
end
gui()</code></pre><p><img src="../time_response.png" alt="The responses in time for different quantity of particles"/></p><p>We see that the responses in time diverge from each other more and more as time goes by. Meaning that if we only calculate the response for a short amount of time <code>34</code>, then the convergence will be accelerated.</p><pre><code class="language-julia">time_arr = 0.:pi:34.2
time_simulations = [TimeSimulation(s;time_arr=time_arr) for s in simulations]

backscattered_waves = [s.response for s in time_simulations]
bM = backscattered_waves[M] # backscattering from largest material
differences = [norm(b - bM) for b in backscattered_waves[1:(M-1)]]./norm(bM)
plot(plot_converge)
plot!(num_particles[1:(M-1)], differences, xlabel = &quot;number of particles&quot;, ylabel =&quot;error %&quot;, label=&quot;time convergence&quot;)</code></pre><p><img src="../compare_convergence.png" alt="Compare converges for responses in time and responses in frequency"/></p><p>The convergence of the time response, for time <code>0&lt;t&lt;34</code>, is much faster. In fact, less than 100 particles are needed to accurately approximate the backscattering from an infinite halfspace. The reason we don&#39;t show these as log plots is because there is a small constant error (about <code>0.01%</code>) due to the discrete Fourier transform. This error is caused by the Gibbs phenomena and by assuming the backscattering is periodic (when it is not). Both these errors are well understood and can be controlled.</p><h2><a class="nav-anchor" id="Calculate-backscattering-only-from-near-surface-particles-1" href="#Calculate-backscattering-only-from-near-surface-particles-1">Calculate backscattering only from near-surface particles</a></h2><p>This last step is about efficiency. We want to only include particle which contribute to the backscattering for short time intervals. To do this we created a region called <code>TimeOfFlight(listener,time)</code>, where every particle in this shape takes less than <code>time</code> for their first scattered wave (due to an incident plane wave) to return to the <code>listener.</code>  More precisely, if <code>listener = (lx,ly)</code>, then every point <code>(x,y)</code> inside this shape satisfies: <code>x-lx+((x-lx)^2+(y-ly)^2)^(1/2)&lt;time</code> and <code>x&gt;0</code>.</p><p>For example, look at the largest quantity of particle we used</p><pre><code class="language-julia">listener_position = [-10.,0.]
shape = TimeOfFlight(listener_position,80.0)
scatter([listener_position[1]],[listener_position[2]]);
annotate!([(listener_position[1], listener_position[2] -max_width/10., &quot;Receiver&quot;)])
plot!.(particles);
plot!(shape)</code></pre><p><img src="../time_of_flight_shape.png" alt="Shows the particles in the shape TimeOfFlight"/></p><p>For time <code>0&lt;t&lt;80</code> the backscattering from these particles is the same as an infinite halfspace filled with particles. To achieve this result we need only the particles inside the shape <code>TimeOfFlight</code> (region with the red outline). The particles outside this shape were unnecessary. To see this inaction:</p><pre><code class="language-julia">times = 40.:15.:80.
near_surface_simulations = map(times) do t
    shape = TimeOfFlight(listener_position,t) # choose a material with particles only in the near surface region
    ps = filter(p -&gt; p⊆shape, particles) # shave off particles
    FrequencySimulation(ps, k_arr; shape=shape) # calculate backscattering
end

time_near_simulations = TimeSimulation.(near_surface_simulations)

plot()
for i in 1:length(times)
    plot!(time_near_simulations[i],label=&quot;time of flight $(times[i])&quot;
        , xlims=(0,maximum(times)+10.), ylims=(-0.6,0.3)
        , xticks = [0.; times], title=&quot;&quot;
    )
end
gui()</code></pre><p><img src="../time_of_flight_response.png" alt="Response from particles in the shapes TimeOfFlight"/></p><p>Note the incident pulse has a thickness of about <code>10</code> in time, which is why the <code>time of flight 40</code> diverges from the other curves slightly before time <code>40</code>, and likewise for the other curves.</p><footer><hr/><a class="previous" href="../../moments/README/"><span class="direction">Previous</span><span class="title">StatisticalMoments</span></a><a class="next" href="../../random_particles/README/"><span class="direction">Next</span><span class="title">Simple random particles example</span></a></footer></article></body></html>
